"""
This type stub file was generated by pyright.
"""

from pyomo.common import Factory

logger = ...
class UnknownSolver:
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, t, v, traceback): # -> None:
        ...
    
    def available(self, exception_flag=...): # -> Literal[False]:
        """Determine if this optimizer is available."""
        ...
    
    def license_is_valid(self): # -> Literal[False]:
        "True if the solver is present and has a valid license (if applicable)"
        ...
    
    def warm_start_capable(self): # -> Literal[False]:
        """True is the solver can accept a warm-start solution."""
        ...
    
    def solve(self, *args, **kwds):
        """Perform optimization and return an SolverResults object."""
        ...
    
    def reset(self):
        """Reset the state of an optimizer"""
        ...
    
    def set_options(self, istr):
        """Set the options in the optimizer from a string."""
        ...
    
    def __bool__(self): # -> Literal[False]:
        ...
    
    def __getattr__(self, attr):
        ...
    


class SolverFactoryClass(Factory):
    def __call__(self, _name=..., **kwds):
        ...
    


LegacySolverFactory = ...
SolverFactory = ...
def check_available_solvers(*args): # -> list[Any]:
    ...

class OptSolver:
    """A generic optimization solver"""
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, t, v, traceback): # -> None:
        ...
    
    @property
    def tee(self): # -> None:
        ...
    
    @tee.setter
    def tee(self, val): # -> None:
        ...
    
    @property
    def suffixes(self): # -> None:
        ...
    
    @suffixes.setter
    def suffixes(self, val): # -> None:
        ...
    
    @property
    def keepfiles(self): # -> None:
        ...
    
    @keepfiles.setter
    def keepfiles(self, val): # -> None:
        ...
    
    @property
    def soln_file(self): # -> None:
        ...
    
    @soln_file.setter
    def soln_file(self, val): # -> None:
        ...
    
    @property
    def log_file(self): # -> None:
        ...
    
    @log_file.setter
    def log_file(self, val): # -> None:
        ...
    
    @property
    def symbolic_solver_labels(self): # -> None:
        ...
    
    @symbolic_solver_labels.setter
    def symbolic_solver_labels(self, val): # -> None:
        ...
    
    @property
    def warm_start_solve(self): # -> None:
        ...
    
    @warm_start_solve.setter
    def warm_start_solve(self, val): # -> None:
        ...
    
    @property
    def warm_start_file_name(self): # -> None:
        ...
    
    @warm_start_file_name.setter
    def warm_start_file_name(self, val): # -> None:
        ...
    
    def __init__(self, **kwds) -> None:
        """Constructor"""
        ...
    
    def default_variable_value(self): # -> None:
        ...
    
    def __bool__(self): # -> Literal[True]:
        ...
    
    def version(self): # -> None:
        """
        Returns a 4-tuple describing the solver executable version.
        """
        ...
    
    def problem_format(self): # -> None:
        """
        Returns the current problem format.
        """
        ...
    
    def set_problem_format(self, format): # -> None:
        """
        Set the current problem format (if it's valid) and update
        the results format to something valid for this problem format.
        """
        ...
    
    def results_format(self): # -> ResultsFormat | None:
        """
        Returns the current results format.
        """
        ...
    
    def set_results_format(self, format): # -> None:
        """
        Set the current results format (if it's valid for the current
        problem format).
        """
        ...
    
    def has_capability(self, cap): # -> Any | Literal[False]:
        """
        Returns a boolean value representing whether a solver supports
        a specific feature. Defaults to 'False' if the solver is unaware
        of an option. Expects a string.

        Example:
        # prints True if solver supports sos1 constraints, and False otherwise
        print(solver.has_capability('sos1')

        # prints True is solver supports 'feature', and False otherwise
        print(solver.has_capability('feature')

        Parameters
        ----------
        cap: str
            The feature

        Returns
        -------
        val: bool
            Whether or not the solver has the specified capability.
        """
        ...
    
    def available(self, exception_flag=...): # -> Literal[True]:
        """True if the solver is available"""
        ...
    
    def license_is_valid(self): # -> Literal[True]:
        "True if the solver is present and has a valid license (if applicable)"
        ...
    
    def warm_start_capable(self): # -> Literal[False]:
        """True is the solver can accept a warm-start solution"""
        ...
    
    def solve(self, *args, **kwds):
        """Solve the problem"""
        ...
    
    def reset(self): # -> None:
        """
        Reset the state of the solver
        """
        ...
    
    def set_options(self, istr): # -> None:
        ...
    
    def set_callback(self, name, callback_fn=...): # -> None:
        """
        Set the callback function for a named callback.

        A call-back function has the form:

            def fn(solver, model):
                pass

        where 'solver' is the native solver interface object and 'model' is
        a Pyomo model instance object.
        """
        ...
    
    def config_block(self, init=...): # -> ConfigBlock:
        ...
    


