"""
This type stub file was generated by pyright.
"""

from pyomo.common.deprecation import RenamedClass
from .base import ExpressionBase
from .boolean_value import BooleanValue
from .numeric_expr import NumericExpression

logger = ...
class BooleanExpression(ExpressionBase, BooleanValue):
    """
    Logical expression base class.

    This class is used to define nodes in an expression
    tree.

    Abstract

    args:
        args (list or tuple): Children of this node.
    """
    __slots__ = ...
    EXPRESSION_SYSTEM = ...
    PRECEDENCE = ...
    def __init__(self, args) -> None:
        ...
    
    @property
    def args(self):
        """
        Return the child nodes

        Returns: Either a list or tuple (depending on the node storage
            model) containing only the child nodes of this node
        """
        ...
    


class BooleanExpressionBase(metaclass=RenamedClass):
    __renamed__new_class__ = BooleanExpression
    __renamed__version__ = ...


def lnot(Y): # -> NotExpression:
    """
    Construct a NotExpression for the passed BooleanValue.
    """
    ...

def equivalent(Y1, Y2): # -> EquivalenceExpression:
    """
    Construct an EquivalenceExpression Y1 == Y2
    """
    ...

def xor(Y1, Y2): # -> XorExpression:
    """
    Construct an XorExpression Y1 xor Y2
    """
    ...

def implies(Y1, Y2): # -> ImplicationExpression:
    """
    Construct an Implication using function, where Y1 implies Y2
    """
    ...

def land(*args): # -> AndExpression | BooleanConstant:
    """
    Construct an AndExpression between passed arguments.
    """
    ...

def lor(*args): # -> OrExpression | BooleanConstant:
    """
    Construct an OrExpression between passed arguments.
    """
    ...

def exactly(n, *args): # -> ExactlyExpression:
    """Creates a new ExactlyExpression

    Require exactly n arguments to be True, to make the expression True

    Usage: exactly(2, m.Y1, m.Y2, m.Y3, ...)

    """
    ...

def atmost(n, *args): # -> AtMostExpression:
    """Creates a new AtMostExpression

    Require at most n arguments to be True, to make the expression True

    Usage: atmost(2, m.Y1, m.Y2, m.Y3, ...)

    """
    ...

def atleast(n, *args): # -> AtLeastExpression:
    """Creates a new AtLeastExpression

    Require at least n arguments to be True, to make the expression True

    Usage: atleast(2, m.Y1, m.Y2, m.Y3, ...)

    """
    ...

def all_different(*args): # -> AllDifferentExpression:
    """Creates a new AllDifferentExpression

    Requires all of the arguments to take on a different value

    Usage: all_different(m.X1, m.X2, ...)
    """
    ...

def count_if(*args): # -> CountIfExpression:
    """Creates a new CountIfExpression

    Counts the number of True-valued arguments

    Usage: count_if(m.Y1, m.Y2, ...)
    """
    ...

class UnaryBooleanExpression(BooleanExpression):
    """
    Abstract class for single-argument logical expressions.
    """
    def nargs(self): # -> Literal[1]:
        """
        Returns number of arguments in expression
        """
        ...
    


class NotExpression(UnaryBooleanExpression):
    """
    This is the node for a NotExpression, this node should have exactly one child
    """
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['Logical Negation']:
        ...
    


class BinaryBooleanExpression(BooleanExpression):
    """
    Abstract class for binary logical expressions.
    """
    def nargs(self): # -> Literal[2]:
        """
        Return the number of argument the expression has
        """
        ...
    


class EquivalenceExpression(BinaryBooleanExpression):
    """
    Logical equivalence statement: Y_1 iff Y_2.

    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['iff']:
        ...
    


class XorExpression(BinaryBooleanExpression):
    """
    Logical Exclusive OR statement: Y_1 âŠ» Y_2
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['xor']:
        ...
    


class ImplicationExpression(BinaryBooleanExpression):
    """
    Logical Implication statement: Y_1 --> Y_2.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['implies']:
        ...
    


class NaryBooleanExpression(BooleanExpression):
    """
    The abstract class for NaryBooleanExpression.

    This class should never be initialized.
    """
    __slots__ = ...
    def __init__(self, args) -> None:
        ...
    
    def nargs(self): # -> int:
        """
        Return the number of expression arguments
        """
        ...
    
    def getname(self, *arg, **kwd): # -> Literal['NaryBooleanExpression']:
        ...
    


class AndExpression(NaryBooleanExpression):
    """
    This is the node for AndExpression.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['and']:
        ...
    
    def add(self, new_arg): # -> BooleanConstant | Self:
        ...
    


class OrExpression(NaryBooleanExpression):
    """
    This is the node for OrExpression.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['or']:
        ...
    
    def add(self, new_arg): # -> Self | BooleanConstant:
        ...
    


class ExactlyExpression(NaryBooleanExpression):
    """
    Logical constraint that exactly N child statements are True.

    The first argument N is expected to be a numeric non-negative integer.
    Subsequent arguments are expected to be Boolean.

    Usage: exactly(1, True, False, False) --> True

    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['exactly']:
        ...
    


class AtMostExpression(NaryBooleanExpression):
    """
    Logical constraint that at most N child statements are True.

    The first argument N is expected to be a numeric non-negative integer.
    Subsequent arguments are expected to be Boolean.

    Usage: atmost(1, True, False, False) --> True

    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['atmost']:
        ...
    


class AtLeastExpression(NaryBooleanExpression):
    """
    Logical constraint that at least N child statements are True.

    The first argument N is expected to be a numeric non-negative integer.
    Subsequent arguments are expected to be Boolean.

    Usage: atleast(1, True, False, False) --> True

    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['atleast']:
        ...
    


class AllDifferentExpression(NaryBooleanExpression):
    """
    Logical expression that all of the N child statements have different values.
    All arguments are expected to be discrete-valued.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *arg, **kwd): # -> Literal['all_different']:
        ...
    


class CountIfExpression(NumericExpression):
    """
    Logical expression that returns the number of True child statements.
    All arguments are expected to be Boolean-valued.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def nargs(self): # -> int:
        ...
    
    def getname(self, *arg, **kwd): # -> Literal['count_if']:
        ...
    


special_boolean_atom_types = ...
