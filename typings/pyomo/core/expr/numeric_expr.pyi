"""
This type stub file was generated by pyright.
"""

from pyomo.common import enums
from pyomo.common.deprecation import deprecated
from pyomo.core.pyomoobject import PyomoObject
from pyomo.core.expr.base import ExpressionBase, NPV_Mixin

logger = ...
_zero_one_optimizations = ...
def enable_expression_optimizations(zero=..., one=...): # -> None:
    """Enable(disable) expression generation optimizations

    There are currently two optimizations available during expression generation:

    - zero: aggressively resolve `0*f(.)` expressions to `0`, `0/f(.)`
      expressions to `0`, and `f(.)**0` expressions to `1`

    - one: aggressively resolve identities: `1*f(.)` expressions to
      `f(.)`, `f(.)/1` expressions to `f(.)`, and `f(.)**1` expressions
      to `f(.)`.

    The default optimizations are `zero=False` and `one=True`.

    Notes
    -----

    Enabling the `zero` optimization can mask certain modeling errors.
    In particular, the optimization will suppress `ZeroDivisionError`s
    that should be raised if `f(.)` resolves to `0` (in the case of
    `0/f(.)`), as well as any errors that would have otherwise been
    raised during the evaluation of `f(.)`.  In addition, optimizing
    `f(.)**0 == 1` is only valid when `f(.)!=0`.  **Users who enable
    this optimization bear responsibility for ensuring that these
    optimizations will be valid for the model.**

    The `one` optimizations should generally be safe.

    Parameters
    ----------
    zero: bool, optional

        If `True` (`False`), enable (disable) the "zero" optimizations.
        If None, leave the optimization state unchanged.

    one: bool, optional

        If `True` (`False`), enable (disable) the "one" optimizations.
        If None, leave the optimization state unchanged.

    """
    ...

class mutable_expression:
    """Context manager for mutable sums.

    This context manager is used to compute a sum while treating the
    summation as a mutable object.

    """
    def __enter__(self): # -> _MutableNPVSumExpression:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


class nonlinear_expression(mutable_expression):
    """Context manager for mutable nonlinear sums.

    This context manager is used to compute a general nonlinear sum
    while treating the summation as a mutable object.

    Note
    ----

    The preferred context manager is :py:class:`mutable_expression`, as
    the return type will be the most specific of
    :py:class:`SumExpression`, :py:class:`LinearExpression`, or
    :py:class:`NPV_SumExpression`.  This context manager will *always*
    return a :py:class:`SumExpression`.

    """
    def __enter__(self): # -> _MutableSumExpression:
        ...
    


class linear_expression(mutable_expression):
    """Context manager for mutable linear sums.

    This context manager is used to compute a linear sum while
    treating the summation as a mutable object.

    Note
    ----

    The preferred context manager is :py:class:`mutable_expression`.
    :py:class:`linear_expression` is an alias to
    :py:class:`mutable_expression` provided for backwards compatibility.

    """
    ...


class NumericValue(PyomoObject):
    """
    This is the base class for numeric values used in Pyomo.
    """
    __slots__ = ...
    __hash__ = ...
    def getname(self, *args, **kwargs): # -> str:
        """
        If this is a component, return the component's name on the owning
        block; otherwise return the value converted to a string
        """
        ...
    
    @property
    def name(self): # -> str:
        ...
    
    @property
    def local_name(self): # -> str:
        ...
    
    def is_numeric_type(self): # -> Literal[True]:
        """Return True if this class is a Pyomo numeric object"""
        ...
    
    def is_constant(self): # -> Literal[False]:
        """Return True if this numeric value is a constant value"""
        ...
    
    def is_fixed(self): # -> Literal[False]:
        """Return True if this is a non-constant value that has been fixed"""
        ...
    
    def is_potentially_variable(self): # -> Literal[False]:
        """Return True if variables can appear in this expression"""
        ...
    
    @deprecated("is_relational() is deprecated in favor of " "is_expression_type(ExpressionType.RELATIONAL)", version='6.4.3')
    def is_relational(self): # -> Literal[False]:
        """
        Return True if this numeric value represents a relational expression.
        """
        ...
    
    def is_indexed(self): # -> Literal[False]:
        """Return True if this numeric value is an indexed object"""
        ...
    
    def polynomial_degree(self): # -> None:
        """
        Return the polynomial degree of the expression.

        Returns:
            :const:`None`
        """
        ...
    
    def __bool__(self): # -> bool:
        """Coerce the value to a bool

        Numeric values can be coerced to bool only if the value /
        expression is constant.  Fixed (but non-constant) or variable
        values will raise an exception.

        Raises:
            PyomoException

        """
        ...
    
    def __float__(self): # -> float:
        """Coerce the value to a floating point

        Numeric values can be coerced to float only if the value /
        expression is constant.  Fixed (but non-constant) or variable
        values will raise an exception.

        Raises:
            TypeError

        """
        ...
    
    def __int__(self) -> int:
        """Coerce the value to an integer

        Numeric values can be coerced to int only if the value /
        expression is constant.  Fixed (but non-constant) or variable
        values will raise an exception.

        Raises:
            TypeError

        """
        ...
    
    def __lt__(self, other) -> bool:
        """
        Less than operator

        This method is called when Python processes statements of the form::

            self < other
            other > self
        """
        ...
    
    def __gt__(self, other) -> bool:
        """
        Greater than operator

        This method is called when Python processes statements of the form::

            self > other
            other < self
        """
        ...
    
    def __le__(self, other) -> bool:
        """
        Less than or equal operator

        This method is called when Python processes statements of the form::

            self <= other
            other >= self
        """
        ...
    
    def __ge__(self, other) -> bool:
        """
        Greater than or equal operator

        This method is called when Python processes statements of the form::

            self >= other
            other <= self
        """
        ...
    
    def __eq__(self, other) -> bool:
        """
        Equal to operator

        This method is called when Python processes the statement::

            self == other
        """
        ...
    
    def __add__(self, other):
        """
        Binary addition

        This method is called when Python processes the statement::

            self + other
        """
        ...
    
    def __sub__(self, other):
        """
        Binary subtraction

        This method is called when Python processes the statement::

            self - other
        """
        ...
    
    def __mul__(self, other):
        """
        Binary multiplication

        This method is called when Python processes the statement::

            self * other
        """
        ...
    
    def __div__(self, other):
        """
        Binary division

        This method is called when Python processes the statement::

            self / other
        """
        ...
    
    def __truediv__(self, other):
        """
        Binary division (when __future__.division is in effect)

        This method is called when Python processes the statement::

            self / other
        """
        ...
    
    def __pow__(self, other):
        """
        Binary power

        This method is called when Python processes the statement::

            self ** other
        """
        ...
    
    def __radd__(self, other):
        """
        Binary addition

        This method is called when Python processes the statement::

            other + self
        """
        ...
    
    def __rsub__(self, other):
        """
        Binary subtraction

        This method is called when Python processes the statement::

            other - self
        """
        ...
    
    def __rmul__(self, other):
        """
        Binary multiplication

        This method is called when Python processes the statement::

            other * self

        when other is not a :class:`NumericValue <pyomo.core.expr.numvalue.NumericValue>` object.
        """
        ...
    
    def __rdiv__(self, other):
        """Binary division

        This method is called when Python processes the statement::

            other / self
        """
        ...
    
    def __rtruediv__(self, other):
        """
        Binary division (when __future__.division is in effect)

        This method is called when Python processes the statement::

            other / self
        """
        ...
    
    def __rpow__(self, other):
        """
        Binary power

        This method is called when Python processes the statement::

            other ** self
        """
        ...
    
    def __iadd__(self, other):
        """
        Binary addition

        This method is called when Python processes the statement::

            self += other
        """
        ...
    
    def __isub__(self, other):
        """
        Binary subtraction

        This method is called when Python processes the statement::

            self -= other
        """
        ...
    
    def __imul__(self, other):
        """
        Binary multiplication

        This method is called when Python processes the statement::

            self *= other
        """
        ...
    
    def __idiv__(self, other):
        """
        Binary division

        This method is called when Python processes the statement::

            self /= other
        """
        ...
    
    def __itruediv__(self, other):
        """
        Binary division (when __future__.division is in effect)

        This method is called when Python processes the statement::

            self /= other
        """
        ...
    
    def __ipow__(self, other):
        """
        Binary power

        This method is called when Python processes the statement::

            self **= other
        """
        ...
    
    def __neg__(self):
        """
        Negation

        This method is called when Python processes the statement::

            - self
        """
        ...
    
    def __pos__(self): # -> Self:
        """
        Positive expression

        This method is called when Python processes the statement::

            + self
        """
        ...
    
    def __abs__(self):
        """Absolute value

        This method is called when Python processes the statement::

            abs(self)
        """
        ...
    
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs): # -> Any:
        ...
    
    def to_string(self, verbose=..., labeler=..., smap=..., compute_values=...): # -> str:
        """Return a string representation of the expression tree.

        Args:
            verbose (bool): If :const:`True`, then the string
                representation consists of nested functions.  Otherwise,
                the string representation is an infix algebraic equation.
                Defaults to :const:`False`.
            labeler: An object that generates string labels for
                non-constant in the expression tree.  Defaults to
                :const:`None`.
            smap: A SymbolMap instance that stores string labels for
                non-constant nodes in the expression tree.  Defaults to
                :const:`None`.
            compute_values (bool): If :const:`True`, then fixed
                expressions are evaluated and the string representation
                of the resulting value is returned.

        Returns:
            A string representation for the expression tree.

        """
        ...
    


class NumericExpression(ExpressionBase, NumericValue):
    """
    The base class for Pyomo expressions.

    This class is used to define nodes in a numeric expression
    tree.

    Args:
        args (list or tuple): Children of this node.
    """
    __slots__ = ...
    EXPRESSION_SYSTEM = ...
    PRECEDENCE = ...
    def __init__(self, args) -> None:
        ...
    
    def nargs(self): # -> Literal[2]:
        ...
    
    @property
    def args(self): # -> Any:
        """
        Return the child nodes

        Returns
        -------
        list or tuple:
            Sequence containing only the child nodes of this node.  The
            return type depends on the node storage model.  Users are
            not permitted to change the returned data (even for the case
            of data returned as a list), as that breaks the promise of
            tree immutability.
        """
        ...
    
    @deprecated('The implicit recasting of a "not potentially variable" ' 'expression node to a potentially variable one is no ' 'longer supported (this violates the immutability ' 'promise for Pyomo5 expression trees).', version='6.4.3')
    def create_potentially_variable_object(self): # -> Self:
        """
        Create a potentially variable version of this object.

        This method returns an object that is a potentially variable
        version of the current object.  In the simplest
        case, this simply sets the value of `__class__`:

            self.__class__ = self.__class__.__mro__[1]

        Note that this method is allowed to modify the current object
        and return it.  But in some cases it may create a new
        potentially variable object.

        Returns:
            An object that is potentially variable.
        """
        ...
    
    def polynomial_degree(self): # -> Any:
        """
        Return the polynomial degree of the expression.

        Returns:
            A non-negative integer that is the polynomial
            degree if the expression is polynomial, or :const:`None` otherwise.
        """
        ...
    


class Numeric_NPV_Mixin(NPV_Mixin):
    __slots__ = ...
    def potentially_variable_base_class(self): # -> type:
        ...
    
    def __neg__(self): # -> NPV_NegationExpression:
        ...
    
    def __abs__(self): # -> NPV_AbsExpression:
        ...
    


class NegationExpression(NumericExpression):
    """
    Negation expressions::

        - x
    """
    __slots__ = ...
    PRECEDENCE = ...
    def nargs(self): # -> Literal[1]:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['neg']:
        ...
    
    def __neg__(self):
        ...
    


class NPV_NegationExpression(Numeric_NPV_Mixin, NegationExpression):
    __slots__ = ...
    def __neg__(self):
        ...
    


class ExternalFunctionExpression(NumericExpression):
    """
    External function expressions

    Example::

        model = ConcreteModel()
        model.a = Var()
        model.f = ExternalFunction(library='foo.so', function='bar')
        expr = model.f(model.a)

    Args:
        args (tuple): children of this node
        fcn: a class that defines this external function
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __init__(self, args, fcn=...) -> None:
        ...
    
    def nargs(self): # -> int:
        ...
    
    def create_node_with_local_data(self, args, classtype=...): # -> Self:
        ...
    
    def getname(self, *args, **kwds):
        ...
    
    def get_arg_units(self):
        """Return the units for this external functions arguments"""
        ...
    
    def get_units(self):
        """Get the units of the return value for this external function"""
        ...
    


class NPV_ExternalFunctionExpression(Numeric_NPV_Mixin, ExternalFunctionExpression):
    __slots__ = ...


class PowExpression(NumericExpression):
    """
    Power expressions::

        x**y
    """
    __slots__ = ...
    PRECEDENCE = ...
    ASSOCIATIVITY = ...
    def getname(self, *args, **kwds): # -> Literal['pow']:
        ...
    


class NPV_PowExpression(Numeric_NPV_Mixin, PowExpression):
    __slots__ = ...


class MaxExpression(NumericExpression):
    """
    Maximum expressions::

        max(x, y, ...)
    """
    __slots__ = ...
    PRECEDENCE = ...
    def nargs(self): # -> int:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['max']:
        ...
    


class NPV_MaxExpression(Numeric_NPV_Mixin, MaxExpression):
    __slots__ = ...


class MinExpression(NumericExpression):
    """
    Minimum expressions::

        min(x, y, ...)
    """
    __slots__ = ...
    PRECEDENCE = ...
    def nargs(self): # -> int:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['min']:
        ...
    


class NPV_MinExpression(Numeric_NPV_Mixin, MinExpression):
    __slots__ = ...


class ProductExpression(NumericExpression):
    """
    Product expressions::

        x*y
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *args, **kwds): # -> Literal['prod']:
        ...
    


class NPV_ProductExpression(Numeric_NPV_Mixin, ProductExpression):
    __slots__ = ...


class MonomialTermExpression(ProductExpression):
    __slots__ = ...
    def getname(self, *args, **kwds): # -> Literal['mon']:
        ...
    
    def create_node_with_local_data(self, args, classtype=...): # -> Any:
        ...
    


class DivisionExpression(NumericExpression):
    """
    Division expressions::

        x/y
    """
    __slots__ = ...
    PRECEDENCE = ...
    def getname(self, *args, **kwds): # -> Literal['div']:
        ...
    


class NPV_DivisionExpression(Numeric_NPV_Mixin, DivisionExpression):
    __slots__ = ...


class SumExpression(NumericExpression):
    """
    Sum expression::

        x + y + ...

    This node represents an "n-ary" sum expression over at least 2 arguments.

    Args:
        args (list): Children nodes

    """
    __slots__ = ...
    PRECEDENCE = ...
    def __init__(self, args) -> None:
        ...
    
    def nargs(self): # -> int:
        ...
    
    @property
    def args(self): # -> list[Any]:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['sum']:
        ...
    
    @deprecated("SumExpression.add() is deprecated.  Please use regular Python operators " "(infix '+' or inplace '+='.)", version='6.6.0')
    def add(self, new_arg):
        ...
    


SumExpressionBase = SumExpression
class LinearExpression(SumExpression):
    """An expression object for linear polynomials.

    This is a derived :py:class`SumExpression` that guarantees all
    arguments are one of the following types:

      - not potentially variable (e.g., native types, Params, or NPV expressions)
      - :py:class:`MonomialTermExpression`
      - :py:class:`VarData`

    Args:
        args (tuple): Children nodes

    """
    __slots__ = ...
    _allowable_linear_expr_arg_types = ...
    _cache = ...
    def __init__(self, args=..., constant=..., linear_coefs=..., linear_vars=...) -> None:
        """A linear expression of the form `const + sum_i(c_i*x_i)`.

        You can specify `args` OR (`constant`, `linear_coefs`, and
        `linear_vars`).  If `args` is provided, it should be a list that
        contains only constants, NPV objects/expressions, variables, or
        :py:class:`MonomialTermExpression` objects.  Alternatively, you
        can specify the constant, the list of linear_coefs and the list
        of linear_vars separately.  Note that these lists are NOT
        preserved.

        """
        ...
    
    @property
    def constant(self): # -> Literal[0] | None:
        ...
    
    @property
    def linear_coefs(self): # -> list[Any] | None:
        ...
    
    @property
    def linear_vars(self): # -> list[Any] | None:
        ...
    
    def create_node_with_local_data(self, args, classtype=...): # -> Self:
        ...
    


class NPV_SumExpression(Numeric_NPV_Mixin, LinearExpression):
    __slots__ = ...


class _MutableSumExpression(SumExpression):
    """
    A mutable SumExpression

    The :func:`add` method is slightly different in that it
    does not create a new sum expression, but modifies the
    :attr:`_args_` data in place.
    """
    __slots__ = ...
    def make_immutable(self): # -> None:
        ...
    
    def __iadd__(self, other):
        ...
    


class _MutableLinearExpression(_MutableSumExpression):
    __slots__ = ...
    def make_immutable(self): # -> None:
        ...
    
    def __iadd__(self, other):
        ...
    


class _MutableNPVSumExpression(_MutableLinearExpression):
    __slots__ = ...
    def make_immutable(self): # -> None:
        ...
    
    def __iadd__(self, other):
        ...
    


class Expr_ifExpression(NumericExpression):
    """A numeric ternary (if-then-else) expression::

        Expr_if(IF=x, THEN=y, ELSE=z)

    Note that this is a mixed expression: `IF` can be numeric or logical;
    `THEN` and `ELSE` are numeric, and the result is a numeric expression.

    """
    __slots__ = ...
    PRECEDENCE = ...
    def nargs(self): # -> Literal[3]:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['Expr_if']:
        ...
    


class NPV_Expr_ifExpression(Numeric_NPV_Mixin, Expr_ifExpression):
    __slots__ = ...


class UnaryFunctionExpression(NumericExpression):
    """
    An expression object for intrinsic (math) functions (e.g. sin, cos, tan).

    Args:
        args (tuple): Children nodes
        name (string): The function name
        fcn: The function that is used to evaluate this expression
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __init__(self, args, name=..., fcn=...) -> None:
        ...
    
    def nargs(self): # -> Literal[1]:
        ...
    
    def create_node_with_local_data(self, args, classtype=...): # -> Self:
        ...
    
    def getname(self, *args, **kwds): # -> None:
        ...
    


class NPV_UnaryFunctionExpression(Numeric_NPV_Mixin, UnaryFunctionExpression):
    __slots__ = ...


class AbsExpression(UnaryFunctionExpression):
    """
    An expression object for the :func:`abs` function.

    Args:
        args (tuple): Children nodes
    """
    __slots__ = ...
    def __init__(self, arg) -> None:
        ...
    
    def create_node_with_local_data(self, args, classtype=...): # -> Self:
        ...
    


class NPV_AbsExpression(Numeric_NPV_Mixin, AbsExpression):
    __slots__ = ...


def decompose_term(expr): # -> tuple[Literal[True], list[tuple[Any, None]]] | tuple[Literal[True], list[tuple[int, Any]]] | tuple[Literal[True], list[tuple[Any, None] | tuple[int, Any] | tuple[Any, Any] | Any]] | tuple[Literal[False], None]:
    """A function that returns a tuple consisting of (1) a flag indicating
    whether the expression is linear, and (2) a list of tuples that
    represents the terms in the linear expression.

    Args:
        expr (expression): The root node of an expression tree

    Returns:
        A tuple with the form ``(flag, list)``.  If :attr:`flag` is
        :const:`False`, then a nonlinear term has been found, and
        :const:`list` is :const:`None`.  Otherwise, :const:`list` is a
        list of tuples: ``(coef, value)``.  If :attr:`value` is
        :const:`None`, then this represents a constant term with value
        :attr:`coef`.  Otherwise, :attr:`value` is a variable object,
        and :attr:`coef` is the numeric coefficient.

    """
    ...

class LinearDecompositionError(Exception):
    ...


class ARG_TYPE(enums.IntEnum):
    MUTABLE = ...
    ASNUMERIC = ...
    INVALID = ...
    NATIVE = ...
    NPV = ...
    PARAM = ...
    VAR = ...
    MONOMIAL = ...
    LINEAR = ...
    SUM = ...
    OTHER = ...


_known_arg_types = ...
def register_arg_type(arg_class, etype): # -> None:
    ...

_add_dispatcher = ...
_add_type_handler_mapping = ...
_iadd_mutablenpvsum_type_handler_mapping = ...
_iadd_mutablenpvsum_dispatcher = ...
_iadd_mutablelinear_type_handler_mapping = ...
_iadd_mutablelinear_dispatcher = ...
_iadd_mutablesum_type_handler_mapping = ...
_iadd_mutablesum_dispatcher = ...
_neg_dispatcher = ...
_neg_type_handler_mapping = ...
_mul_dispatcher = ...
_mul_type_handler_mapping = ...
_div_dispatcher = ...
_div_type_handler_mapping = ...
_pow_dispatcher = ...
_pow_type_handler_mapping = ...
_abs_dispatcher = ...
_abs_type_handler_mapping = ...
_fcn_dispatcher = ...
_fcn_type_handler_mapping = ...
def ceil(arg):
    ...

def floor(arg):
    ...

def exp(arg):
    ...

def log(arg):
    ...

def log10(arg):
    ...

def sqrt(arg):
    ...

def sin(arg):
    ...

def cos(arg):
    ...

def tan(arg):
    ...

def sinh(arg):
    ...

def cosh(arg):
    ...

def tanh(arg):
    ...

def asin(arg):
    ...

def acos(arg):
    ...

def atan(arg):
    ...

def asinh(arg):
    ...

def acosh(arg):
    ...

def atanh(arg):
    ...

def Expr_if(IF_=..., THEN_=..., ELSE_=..., **kwargs): # -> int | Expr_ifExpression | NPV_Expr_ifExpression | None:
    """
    Function used to construct a conditional numeric expression.

    This function accepts either of the following signatures:

       - Expr_if(IF={expr}, THEN={expr}, ELSE={expr})
       - Expr_if(IF_={expr}, THEN_={expr}, ELSE_={expr})

    (the former is historical, and the latter is required to support Cythonization)
    """
    ...

NPV_expression_types = ...
