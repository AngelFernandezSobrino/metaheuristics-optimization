"""
This type stub file was generated by pyright.
"""

from pyomo.core.expr.base import ExpressionArgs_Mixin, ExpressionBase, NPV_Mixin
from pyomo.core.expr.logical_expr import BooleanExpression
from pyomo.core.expr.numeric_expr import NumericExpression, Numeric_NPV_Mixin
from pyomo.core.expr.numvalue import NumericValue
from pyomo.core.expr.visitor import ExpressionReplacementVisitor, StreamBasedExpressionVisitor

logger = ...
class _NotSpecified:
    ...


class GetItemExpression(ExpressionBase):
    """
    Expression to call :func:`__getitem__` on the base object.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __new__(cls, args=...): # -> Self:
        ...
    
    def __getattr__(self, attr): # -> GetAttrExpression | Structural_GetAttrExpression | NPV_Structural_GetAttrExpression:
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self): # -> int:
        ...
    
    def getname(self, *args, **kwds):
        ...
    
    def nargs(self): # -> int:
        ...
    


class Numeric_GetItemExpression(GetItemExpression, NumericExpression):
    __slots__ = ...
    def nargs(self): # -> int:
        ...
    


class NPV_Numeric_GetItemExpression(Numeric_NPV_Mixin, Numeric_GetItemExpression):
    __slots__ = ...


class Boolean_GetItemExpression(GetItemExpression, BooleanExpression):
    __slots__ = ...


class NPV_Boolean_GetItemExpression(NPV_Mixin, Boolean_GetItemExpression):
    __slots__ = ...


class Structural_GetItemExpression(ExpressionArgs_Mixin, GetItemExpression):
    __slots__ = ...


class NPV_Structural_GetItemExpression(NPV_Mixin, Structural_GetItemExpression):
    __slots__ = ...


class GetAttrExpression(ExpressionBase):
    """
    Expression to call :func:`__getattr__` on the base object.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __new__(cls, args=...): # -> Self | Structural_GetAttrExpression | NPV_Structural_GetAttrExpression:
        ...
    
    def __getattr__(self, attr): # -> GetAttrExpression | Structural_GetAttrExpression | NPV_Structural_GetAttrExpression:
        ...
    
    def __getitem__(self, *idx): # -> GetItemExpression:
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __call__(self, *args, **kwargs):
        """
        Return the value of this object.
        """
        ...
    
    def getname(self, *args, **kwds): # -> Literal['getattr']:
        ...
    
    def nargs(self): # -> Literal[2]:
        ...
    


class Numeric_GetAttrExpression(GetAttrExpression, NumericExpression):
    __slots__ = ...


class NPV_Numeric_GetAttrExpression(Numeric_NPV_Mixin, Numeric_GetAttrExpression):
    __slots__ = ...


class Boolean_GetAttrExpression(GetAttrExpression, BooleanExpression):
    __slots__ = ...


class NPV_Boolean_GetAttrExpression(NPV_Mixin, Boolean_GetAttrExpression):
    __slots__ = ...


class Structural_GetAttrExpression(ExpressionArgs_Mixin, GetAttrExpression):
    __slots__ = ...


class NPV_Structural_GetAttrExpression(NPV_Mixin, Structural_GetAttrExpression):
    __slots__ = ...


class CallExpression(NumericExpression):
    """
    Expression to call :func:`__call__` on the base object.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __init__(self, args, kwargs) -> None:
        ...
    
    def nargs(self): # -> int:
        ...
    
    def __getattr__(self, attr): # -> GetAttrExpression | Structural_GetAttrExpression | NPV_Structural_GetAttrExpression:
        ...
    
    def __getitem__(self, *idx): # -> GetItemExpression:
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self): # -> int:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['call']:
        ...
    


class _TemplateSumExpression_argList:
    """A virtual list to represent the expanded SumExpression args

    This class implements a "virtual args list" for
    TemplateSumExpressions without actually generating the expanded
    expression.  It can be accessed either in "one-pass" without
    generating a list of template argument values (more efficient), or
    as a random-access list (where it will have to create the full list
    of argument values (less efficient).

    The instance can be used as a context manager to both lock the
    IndexTemplate values within this context and to restore their original
    values upon exit.

    It is (intentionally) not iterable.

    """
    def __init__(self, TSE) -> None:
        ...
    
    def __len__(self):
        ...
    
    def __getitem__(self, i):
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, tb): # -> None:
        ...
    


class TemplateSumExpression(NumericExpression):
    """
    Expression to represent an unexpanded sum over one or more sets.
    """
    __slots__ = ...
    PRECEDENCE = ...
    def __init__(self, args, _iters) -> None:
        ...
    
    def nargs(self): # -> int:
        ...
    
    @property
    def args(self): # -> _TemplateSumExpression_argList:
        ...
    
    def template_args(self): # -> tuple[Any, ...]:
        ...
    
    def template_iters(self): # -> Any:
        ...
    
    def create_node_with_local_data(self, args): # -> Self:
        ...
    
    def getname(self, *args, **kwds): # -> Literal['SUM']:
        ...
    
    def is_potentially_variable(self): # -> bool:
        ...
    
    def to_string(self, verbose=..., smap=...): # -> str:
        ...
    


class IndexTemplate(NumericValue):
    """A "placeholder" for an index value in template expressions.

    This class is a placeholder for an index value within a template
    expression.  That is, given the expression template for "m.x[i]",
    where `m.z` is indexed by `m.I`, the expression tree becomes:

    _GetItem:
       - m.x
       - IndexTemplate(_set=m.I, _value=None)

    Constructor Arguments:
       _set: the Set from which this IndexTemplate can take values
    """
    __slots__ = ...
    def __init__(self, _set, index=..., _id=..., _group=...) -> None:
        ...
    
    def __deepcopy__(self, memo): # -> Self:
        ...
    
    def __call__(self, exception=...): # -> type[_NotSpecified] | tuple[type[_NotSpecified]] | None:
        """
        Return the value of this object.
        """
        ...
    
    def is_fixed(self): # -> Literal[True]:
        """
        Returns True because this value is fixed.
        """
        ...
    
    def is_potentially_variable(self): # -> Literal[False]:
        """Returns False because index values cannot be variables.

        The IndexTemplate represents a placeholder for an index value
        for an IndexedComponent, and at the moment, Pyomo does not
        support variable indirection.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def getname(self, fully_qualified=..., name_buffer=..., relative_to=...): # -> LiteralString:
        ...
    
    def set_value(self, values=..., lock=...): # -> None:
        ...
    
    def lock(self, lock): # -> type[_NotSpecified] | tuple[type[_NotSpecified]]:
        ...
    
    def unlock(self, lock): # -> None:
        ...
    


class _TemplateResolver(StreamBasedExpressionVisitor):
    def beforeChild(self, node, child, child_idx): # -> tuple[Literal[False], Any] | tuple[Literal[True], None]:
        ...
    
    def exitNode(self, node, args):
        ...
    
    def initializeWalker(self, expr): # -> tuple[Literal[False], Any] | tuple[Literal[True], None]:
        ...
    


def resolve_template(expr): # -> tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | list[Any] | None, ...] | list[Any] | Any | None:
    """Resolve a template into a concrete expression

    This takes a template expression and returns the concrete equivalent
    by substituting the current values of all IndexTemplate objects and
    resolving (evaluating and removing) all GetItemExpression,
    GetAttrExpression, and TemplateSumExpression expression nodes.

    """
    ...

class _wildcard_info:
    __slots__ = ...
    def __init__(self, src, obj) -> None:
        ...
    
    def advance(self): # -> None:
        ...
    
    def reset(self): # -> None:
        ...
    
    def restore(self): # -> None:
        ...
    


class ReplaceTemplateExpression(ExpressionReplacementVisitor):
    template_types = ...
    def __init__(self, substituter, *args, **kwargs) -> None:
        ...
    
    def beforeChild(self, node, child, child_idx): # -> tuple[Literal[False], Any] | tuple[Literal[True], None]:
        ...
    


def substitute_template_expression(expr, substituter, *args, **kwargs): # -> tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | list[Any] | None, ...] | list[Any] | Any | None:
    r"""Substitute IndexTemplates in an expression tree.

    This is a general utility function for walking the expression tree
    and substituting all occurrences of IndexTemplate and
    GetItemExpression nodes.

    Parameters
    ----------
    expr : NumericExpression
        the source template expression

    substituter: Callable
        method taking ``(expression, *args)`` and returning the new object

    \*args:
        positional arguments passed directly to the substituter

    Returns
    -------
    NumericExpression :
        a new expression tree with all substitutions done

    """
    ...

class _GetItemIndexer:
    def __init__(self, expr) -> None:
        ...
    
    def nargs(self): # -> int:
        ...
    
    def arg(self, i):
        ...
    
    @property
    def base(self):
        ...
    
    @property
    def args(self): # -> list[Any]:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


def substitute_getitem_with_param(expr, _map): # -> IndexTemplate:
    """A simple substituter to replace _GetItem nodes with mutable Params.

    This substituter will replace all GetItemExpression nodes with a
    new Param.  For example, this method will create expressions
    suitable for passing to DAE integrators
    """
    ...

def substitute_template_with_value(expr): # -> NumericConstant | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | list[Any] | None, ...] | list[Any] | Any | None:
    """A simple substituter to expand expression for current template

    This substituter will replace all GetItemExpression / IndexTemplate
    nodes with the actual _ComponentData based on the current value of
    the IndexTemplate(s)

    """
    ...

class _set_iterator_template_generator:
    """Replacement iterator that returns IndexTemplates

    In order to generate template expressions, we hijack the normal Set
    iteration mechanisms so that this iterator is returned instead of
    the usual iterator.  This iterator will return IndexTemplate
    object(s) instead of the actual Set items the first time next() is
    called.
    """
    def __init__(self, _set, context) -> None:
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def __next__(self): # -> IndexTemplate | tuple[IndexTemplate, ...]:
        ...
    
    next = ...


class _template_iter_context:
    """Manage the iteration context when generating templatized rules

    This class manages the context tracking when generating templatized
    rules.  It has two methods (`sum_template` and `get_iter`) that
    replace standard functions / methods (`sum` and
    :py:meth:`_FiniteSetMixin.__iter__`, respectively).  It also tracks
    unique identifiers for IndexTemplate objects and their groupings
    within `sum()` generators.
    """
    def __init__(self) -> None:
        ...
    
    def get_iter(self, _set): # -> _set_iterator_template_generator:
        ...
    
    def npop_cache(self, n): # -> list[Any]:
        ...
    
    def next_id(self): # -> int:
        ...
    
    def next_group(self): # -> int:
        ...
    
    def sum_template(self, generator): # -> TemplateSumExpression:
        ...
    


class _template_iter_manager:
    class _iter_wrapper:
        __slots__ = ...
        def __init__(self, cls, context) -> None:
            ...
        
        def acquire(self): # -> None:
            ...
        
        def release(self): # -> None:
            ...
        
    
    
    class _pause_template_iter_manager:
        __slots__ = ...
        def __init__(self, iter_manager) -> None:
            ...
        
        def __enter__(self): # -> Self:
            ...
        
        def __exit__(self, et, ev, tb): # -> None:
            ...
        
    
    
    def __init__(self) -> None:
        ...
    
    def init(self, context, *iter_fcns): # -> Self:
        ...
    
    def acquire(self): # -> None:
        ...
    
    def release(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, et, ev, tb): # -> None:
        ...
    
    def pause(self): # -> nullcontext[None] | _pause_template_iter_manager:
        ...
    


_TemplateIterManager = ...
def templatize_rule(block, rule, index_set): # -> tuple[Any, tuple[IndexTemplate | tuple[IndexTemplate, ...] | tuple[()]] | tuple[IndexTemplate, ...] | tuple[()]]:
    ...

def templatize_constraint(con): # -> tuple[EqualityExpression | InequalityExpression | RangedExpression | Any, tuple[IndexTemplate | tuple[IndexTemplate, ...] | tuple[()]] | tuple[IndexTemplate, ...] | tuple[()]]:
    ...

