"""
This type stub file was generated by pyright.
"""

from pyomo.common.pyomo_typing import overload
from ctypes import Structure
from pyomo.core.expr.numvalue import NumericConstant
from pyomo.core.base.component import Component

logger = ...
nan = ...
class ExternalFunction(Component):
    """Interface to an external (non-algebraic) function.

    :class:`ExternalFunction` provides an interface for declaring
    general user-provided functions, and then embedding calls to the
    external functions within Pyomo expressions.

    .. note::

       Just because you can express a Pyomo model with external
       functions does not mean that the resulting model is solvable.  In
       particular, linear solvers do not accept external functions.  The
       AMPL Solver Library (ASL) interface does support external
       functions for general nonlinear solvers compiled against it, but
       only allows functions in compiled libraries through the
       :class:`AMPLExternalFunction` interface.

    """
    def __new__(cls, *args, **kwargs): # -> Self:
        ...
    
    @overload
    def __init__(self, function=..., gradient=..., hessian=..., *, fgh=...) -> None:
        ...
    
    @overload
    def __init__(self, *, library: str, function: str) -> None:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        """Construct a reference to an external function.

        There are two fundamental interfaces supported by
        :class:`ExternalFunction`: Python callback functions and AMPL
        external functions.

        **Python callback functions** (:class:`PythonCallbackFunction`
        interface)

        Python callback functions can be specified one of two ways:

        1. FGH interface:

          A single external function call with a signature matching the
          :meth:`evaluate_fgh()` method.

        2. Independent functions:

          One to three functions that can evaluate the function value,
          gradient of the function [partial derivatives] with respect to
          its inputs, and the Hessian of the function [partial second
          derivatives].  The ``function`` interface expects a function
          matching the prototype:

          .. code::

             def function(*args): float

          The ``gradient`` and ``hessian`` interface expect functions
          matching the prototype:

          .. code::

             def gradient_or_hessian(args, fixed=None): List[float]

          Where ``args`` is a tuple of function arguments and ``fixed``
          is either None or a list of values equal in length to ``args``
          indicating which arguments are currently fixed (``True``) or
          variable (``False``).

        **ASL function libraries** (:class:`AMPLExternalFunction` interface)

        Pyomo can also call functions compiled as part of an AMPL
        External Function library (see the `User-defined functions
        <https://www.ampl.com/REFS/HOOKING/#userdefinedfuncs>`_ section
        in the `Hooking your solver to AMPL
        <https://www.ampl.com/REFS/hooking3.pdf>`_ report).  Links to
        these functions are declared by creating an
        :class:`ExternalFunction` and passing the compiled library name
        (or path) to the ``library`` keyword and the name of the
        function to the ``function`` keyword.

        """
        ...
    
    def get_units(self): # -> _PyomoUnit:
        """Return the units for this ExternalFunction"""
        ...
    
    def get_arg_units(self): # -> list[_PyomoUnit]:
        """Return the units for this ExternalFunctions arguments"""
        ...
    
    def __call__(self, *args): # -> ExternalFunctionExpression | NPV_ExternalFunctionExpression:
        """Return a Pyomo expression that evaluates this function

        Note that this does not evaluate the external function
        represented by this :class:`ExternalFunction` component, but
        rather generates a Pyomo expression object that represents
        symbolic evaluation of the external function at the specified
        arguments (which themselves may be Pyomo expression objects).

        Parameters
        ----------
        *args:
            Arguments (constants, variables, expressions) to pass to
            this External function.

        Returns
        -------
        ExternalFunctionExpression or NPV_ExternalFunctionExpression:
            The new Pyomo expression node.

        """
        ...
    
    def evaluate(self, args):
        """Return the value of the function given the specified arguments

        Parameters
        ----------
        args: Iterable
            Iterable containing the arguments to pass to the external
            function.  Non-native type elements will be converted to a
            native value using the :py:func:`value()` function.

        Returns
        -------
        float
            The return value of the function evaluated at `args`
        """
        ...
    
    def evaluate_fgh(self, args, fixed=..., fgh=...): # -> tuple[Any, Any | None, Any | None]:
        """Evaluate the function and gradients given the specified arguments

        This evaluates the function given the specified arguments
        returning a 3-tuple of (function value [f], list of first partial
        derivatives [g], and the upper triangle of the Hessian matrix
        [h]).

        Parameters
        ----------
        args: Iterable
            Iterable containing the arguments to pass to the external
            function.  Non-native type elements will be converted to a
            native value using the :py:func:`value()` function.

        fixed: Optional[List[bool]]
            List of values indicating if the corresponding argument
            value is fixed.  Any fixed indices are guaranteed to return
            0 for first and second derivatives, regardless of what is
            computed by the external function.

        fgh: {0, 1, 2}
            What evaluations to return:

            * **0**: just return function evaluation
            * **1**: return function and first derivatives
            * **2**: return function, first derivatives, and hessian matrix

            Any return values not requested will be `None`.

        Returns
        -------
        f: float
            The return value of the function evaluated at `args`
        g: List[float] or None
            The list of first partial derivatives
        h: List[float] or None
            The upper-triangle of the Hessian matrix (second partial
            derivatives), stored column-wise.  Element :math:`H_{i,j}`
            (with :math:`0 <= i <= j < N` are mapped using
            :math:`h[i + j*(j + 1)/2] == H_{i,j}`.

        """
        ...
    


class AMPLExternalFunction(ExternalFunction):
    __autoslot_mappers__ = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def load_library(self): # -> None:
        ...
    


class _PythonCallbackFunctionID(NumericConstant):
    """A specialized NumericConstant to preserve FunctionIDs through deepcopy.

    Function IDs are effectively pointers back to the
    PythonCallbackFunction.  As such, we need special handling to
    maintain / preserve the correct linkages through deepcopy (and
    model.clone()).

    """
    __slots__ = ...
    __autoslot_mappers__ = ...
    def is_constant(self): # -> Literal[False]:
        ...
    


class PythonCallbackFunction(ExternalFunction):
    __autoslot_mappers__ = ...
    global_registry = ...
    global_id_to_fid = ...
    @classmethod
    def register_instance(cls, instance): # -> int:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __call__(self, *args): # -> ExternalFunctionExpression | NPV_ExternalFunctionExpression:
        ...
    


class _ARGLIST(Structure):
    """Mock up the arglist structure from AMPL's funcadd.h

    This data structure is populated by AMPL when calling external
    functions (for both passing in the function arguments and retrieving
    the derivative/Hessian information.
    """
    _fields_ = ...
    def __init__(self, args, fgh=..., fixed=...) -> None:
        ...
    


class _AMPLEXPORTS(Structure):
    ...


class _AMPLEXPORTS(Structure):
    """Mock up the AmplExports structure from AMPL's funcadd.h

    The only thing we really need here is to be able to override the
    Addfunc function pointer to point back into Python so we can
    intercept the registration of external AMPL functions.  Ideally, we
    would populate the other function pointers as well, but that is
    trickier than it sounds, and at least so far is completely unneeded.
    """
    AMPLFUNC = ...
    ADDFUNC = ...
    RANDSEEDSETTER = ...
    ADDRANDINIT = ...
    ATRESET = ...
    _fields_ = ...


