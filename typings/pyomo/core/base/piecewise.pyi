"""
This type stub file was generated by pyright.
"""

import enum
from pyomo.common.deprecation import RenamedClass
from pyomo.core.base.block import Block, BlockData
from pyomo.core.base.component import ModelComponentFactory

"""
This file contains a library of functions needed to construct
piecewise constraints for a Pyomo model. All piecewise types except
for SOS2, BIGM_SOS1, BIGM_BIN were taken from the paper:

Mixed-Integer Models for Non-separable Piecewise Linear Optimization:
Unifying framework and Extensions (Vielma, Nemhauser 2008).

TODO: Add regression tests for the following completed tasks
  - user not providing floats can be an major issue for BIGM's and MC
  - nonconvex/nonconcave functions - BIGM_SOS1, BIGM_SOS2 ***** possible edge case bug

Possible Extensions
  - Consider another piecewise rep ("SOS2_MANUAL"?) where we manually implement
    extra constraints to define an SOS2 set, this would be compatible with GLPK,
    http://winglpk.sourceforge.net/media/glpk-sos2_02.pdf
  - double check that LOG and DLOG reps really do require (2^n)+1 points, or can
    we just add integer cuts (or something more intelligent) in order to handle
    piecewise functions without 2^n polytopes
  - piecewise for functions of the form y = f(x1,x2,...)

"""
logger = ...
class PWRepn(str, enum.Enum):
    SOS2 = ...
    BIGM_BIN = ...
    BIGM_SOS1 = ...
    CC = ...
    DCC = ...
    DLOG = ...
    LOG = ...
    MC = ...
    INC = ...


class Bound(str, enum.Enum):
    Lower = ...
    Upper = ...
    Equal = ...


_WARNING_TOLERANCE = ...
class PiecewiseData(BlockData):
    """
    This class defines the base class for all linearization
    and piecewise constraint generators..
    """
    def __init__(self, parent) -> None:
        ...
    
    def updateBoundType(self, bound_type): # -> None:
        ...
    
    def updatePoints(self, domain_pts, range_pts): # -> None:
        ...
    
    def build_constraints(self, functor, x_var, y_var): # -> None:
        ...
    
    def referenced_variables(self): # -> tuple[None, None]:
        ...
    
    def __call__(self, x):
        ...
    


class _PiecewiseData(metaclass=RenamedClass):
    __renamed__new_class__ = PiecewiseData
    __renamed__version__ = ...


class _SimpleSinglePiecewise:
    """
    Called when the piecewise points list has only two points
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _SimplifiedPiecewise:
    """
    Called when piecewise constraints are simplified due to a lower bounding
    convex function or an upper bounding concave function
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _SOS2Piecewise:
    """
    Called to generate Piecewise constraint using the SOS2 formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _DCCPiecewise:
    """
    Called to generate Piecewise constraint using the DCC formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _DLOGPiecewise:
    """
    Called to generate Piecewise constraint using the DLOG formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _CCPiecewise:
    """
    Called to generate Piecewise constraint using the CC formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _LOGPiecewise:
    """
    Called to generate Piecewise constraint using the LOG formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _MCPiecewise:
    """
    Called to generate Piecewise constraint using the MC formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _INCPiecewise:
    """
    Called to generate Piecewise constraint using the INC formulation
    """
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


class _BIGMPiecewise:
    """
    Called to generate Piecewise constraint using the BIGM formulation
    """
    def __init__(self, binary=...) -> None:
        ...
    
    def construct(self, pblock, x_var, y_var): # -> None:
        ...
    


@ModelComponentFactory.register("Constraints that contain piecewise linear expressions.")
class Piecewise(Block):
    r"""Adds piecewise constraints to a Pyomo model for functions of the
    form, y = f(x).

    Examples
    --------

    .. code::

        model.const = Piecewise(index_1,...,index_n,yvar,xvar,**Keywords)
        model.const = Piecewise(yvar,xvar,**Keywords)

    Parameters
    ----------
    pw_pts : dict
        A dictionary of lists (keys are index set) or a single list (for
        the non-indexed case or when an identical set of breakpoints is
        used across all indices) defining the set of domain breakpoints
        for the piecewise linear function. **ALWAYS REQUIRED**

    pw_repn : str

        Indicates the type of piecewise representation to use. This can
        have a major impact on solver performance.  Choices: (Default
        'SOS2')

           - ``SOS2``: +
               Standard representation using sos2 constraints
           - ``BIGM_BIN``:
               BigM constraints with binary variables.  Theoretically
               tightest M values are automatically determined.
           - ``BIGM_SOS1``:
               BigM constraints with sos1 variables.  Theoretically
               tightest M values are automatically determined.
           - ``DCC``: \*+
               Disaggregated convex combination model
           - ``DLOG``: \*+
               Logarithmic disaggregated convex combination model
           - ``CC``: \*+
               Convex combination model
           - ``LOG``: \*+
               Logarithmic branching convex combination
           - ``MC``: \*
               Multiple choice model
           - ``INC``: \*+
               Incremental (delta) method

        .. note::

            \+\: Supports step functions

            \*\: From "Mixed-Integer Models for Non-separable Piecewise Linear
            Optimization: Unifying framework and Extensions" (Vielma,
            Nemhauser 2008)

        .. seealso::
            Refer to the optional 'force_pw' keyword.

    pw_constr_type : str
        Indicates the bound type of the piecewise function. Choices:

           - ``UB`` - y variable is bounded above by piecewise function
           - ``LB`` - y variable is bounded below by piecewise function
           - ``EQ`` - y variable is equal to the piecewise function

    f_rule : f(model,i,j,...,x), {}, [], ()
        An object that returns a numeric value that is the range value
        corresponding to each piecewise domain point. For functions, the
        first argument must be a Pyomo model. The last argument is the
        domain value at which the function evaluates (Not a Pyomo
        Var). Intermediate arguments are the corresponding indices of
        the Piecewise component (if any).  Otherwise, the object can be
        a dictionary of lists/tuples (with keys the same as the indexing
        set) or a singe list/tuple (when no indexing set is used or when
        all indices use an identical piecewise function).  Examples:

        .. code:: python

            # A function which changes with index
            def f(model,j,x):
                if (j == 2):
                    return x**2 + 1.0
                else:
                    return x**2 + 5.0

            # A nonlinear function
            f = lambda model, x: return exp(x) + value(model.p)
            # (where model.p is a Pyomo Param)

            # A step function
            f = [0,0,1,1,2,2]

    force_pw : bool
        Using the given function rule and pw_pts, a check for
        convexity/concavity is implemented. If (1) the function is
        convex and the piecewise constraints are lower bounds or if (2)
        the function is concave and the piecewise constraints are upper
        bounds then the piecewise constraints will be substituted for
        linear constraints. Setting 'force_pw=True' will force the use
        of the original piecewise constraints even when one of these two
        cases applies.

    warning_tol : float, default=1e-8
        To aid in debugging, a warning is printed when consecutive
        slopes of piecewise segments are within <warning_tol> of each
        other.

    warn_domain_coverage : bool, default=True
        Print a warning when the feasible region of the domain variable
        is not completely covered by the piecewise breakpoints.

    unbounded_domain_var : bool, default=False
        Allow an unbounded or partially bounded Pyomo Var to be used as
        the domain variable.

        .. note::
            This does not imply unbounded piecewise segments will be
            constructed. The outermost piecewise breakpoints will bound
            the domain variable at each index. However, the Var
            attributes .lb and .ub will not be modified.

    """
    _ComponentDataClass = PiecewiseData
    def __new__(cls, *args, **kwds): # -> Self:
        ...
    
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def construct(self, *args, **kwds): # -> None:
        """
        A quick hack to call add after data has been loaded.
        """
        ...
    
    def add(self, index, _is_indexed=...):
        ...
    


class SimplePiecewise(PiecewiseData, Piecewise):
    def __init__(self, *args, **kwds) -> None:
        ...
    


class IndexedPiecewise(Piecewise):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


