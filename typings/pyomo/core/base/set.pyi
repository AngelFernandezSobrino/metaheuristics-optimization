"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator
from typing import Any as typingAny, Type, Union
from pyomo.common.deprecation import RenamedClass, deprecated
from pyomo.common.errors import PyomoException
from pyomo.common.pyomo_typing import overload
from pyomo.core.base.disable_methods import disable_methods
from pyomo.core.base.initializer import InitializerBase
from pyomo.core.base.component import Component, ComponentData, ModelComponentFactory
from pyomo.core.base.indexed_component import IndexedComponent
from pyomo.core.base.global_set import GlobalSetBase

logger = ...
_inf = ...
FLATTEN_CROSS_PRODUCT = ...
def process_setarg(arg): # -> tuple[SetData, None] | tuple[SetData, ComponentSet] | tuple[Set | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet, ComponentSet]:
    ...

@deprecated('The set_options decorator is deprecated; create Sets from ' 'functions explicitly by passing the function to the Set ' 'constructor using the "initialize=" keyword argument.', version='5.7')
def set_options(**kwds): # -> Callable[..., Any]:
    """
    This is a decorator for set initializer functions.  This
    decorator allows an arbitrary dictionary of values to passed
    through to the set constructor.

    Examples
    --------

    .. code::

        @set_options(dimen=3)
        def B_index(model):
            return [(i,i+1,i*i) for i in model.A]

        @set_options(domain=Integers)
        def B_index(model):
            return range(10)

    """
    ...

def simple_set_rule(rule): # -> PyomoObject | Any:
    """
    This is a decorator that translates None into Set.End.
    This supports a simpler syntax in set rules, though these can be
    more difficult to debug when errors occur.

    Examples
    --------

    .. code::

        @simple_set_rule
        def A_rule(model, i, j):
            ...

    """
    ...

class UnknownSetDimen:
    ...


class SetInitializer(InitializerBase):
    """An Initializer wrapper for returning Set objects

    This initializer wraps another Initializer and converts the return
    value to a proper Pyomo Set.  If the initializer is None, then Any
    is returned.  This initializer can be 'intersected' with another
    initializer to return the SetIntersect of the Sets returned by the
    initializers.

    """
    __slots__ = ...
    def __init__(self, init, allow_generators=...) -> None:
        ...
    
    def intersect(self, other): # -> None:
        ...
    
    def __call__(self, parent, idx, obj): # -> SetData | Set | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def constant(self): # -> Literal[True]:
        ...
    
    def contains_indices(self): # -> Literal[False]:
        ...
    
    def indices(self):
        ...
    
    def setdefault(self, val): # -> None:
        ...
    


class SetIntersectInitializer(InitializerBase):
    """An Initializer that returns the intersection of two SetInitializers

    Users will typically not create a SetIntersectInitializer directly.
    Instead, SetInitializer.intersect() may return a SetInitializer that
    contains a SetIntersectInitializer instance.

    """
    __slots__ = ...
    def __init__(self, setA, setB) -> None:
        ...
    
    def __call__(self, parent, idx): # -> SetIntersection | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def constant(self):
        ...
    
    def contains_indices(self):
        ...
    
    def indices(self):
        ...
    


class BoundsInitializer(InitializerBase):
    """An Initializer wrapper that converts bounds information to a RangeSet

    The BoundsInitializer wraps another initializer that is expected to
    return valid arguments to the RangeSet constructor.  Nominally, this
    would be bounds information in the form of (lower bound, upper
    bound), but could also be a single scalar or a 3-tuple.  Calling
    this initializer will return a RangeSet object.

    BoundsInitializer objects can be intersected with other
    SetInitializer objects using the SetInitializer.intersect() method.

    """
    __slots__ = ...
    def __init__(self, init, default_step=...) -> None:
        ...
    
    def __call__(self, parent, idx): # -> RangeSet | AbstractFiniteScalarRangeSet | AbstractInfiniteScalarRangeSet:
        ...
    
    def constant(self):
        ...
    
    def setdefault(self, val): # -> None:
        ...
    


class TuplizeError(PyomoException):
    ...


class TuplizeValuesInitializer(InitializerBase):
    """An initializer wrapper that will "tuplize" a sequence

    This initializer takes the result of another initializer, and if it
    is a sequence that does not already contain tuples, will convert it
    to a sequence of tuples, each of length 'dimen' before returning it.

    """
    __slots__ = ...
    def __new__(cls, *args): # -> Self | None:
        ...
    
    def __init__(self, _init) -> None:
        ...
    
    def __call__(self, parent, index): # -> type[Skip] | tuple[Any, ...] | Sequence[Any] | Generator[tuple[Any, ...], None, None]:
        ...
    
    def constant(self):
        ...
    
    def contains_indices(self):
        ...
    
    def indices(self):
        ...
    


class _NotFound:
    "Internal type flag used to indicate if an object is not found in a set"
    ...


class SetData(ComponentData):
    """The base for all Pyomo objects that can be used as a component
    indexing set.

    Derived versions of this class can be used as the Index for any
    IndexedComponent (including IndexedSet)."""
    __slots__ = ...
    def __contains__(self, value): # -> bool:
        ...
    
    def get(self, value, default=...):
        ...
    
    def isdiscrete(self): # -> Literal[False]:
        """Returns True if this set admits only discrete members"""
        ...
    
    def isfinite(self): # -> Literal[False]:
        """Returns True if this is a finite discrete (iterable) Set"""
        ...
    
    def isordered(self): # -> Literal[False]:
        """Returns True if this is an ordered finite discrete (iterable) Set"""
        ...
    
    def subsets(self, expand_all_set_operators=...): # -> Iterator[Self]:
        ...
    
    def __iter__(self) -> Iterator[typingAny]:
        """Iterate over the set members

        Raises AttributeError for non-finite sets.  This must be
        declared for non-finite sets because scalar sets inherit from
        IndexedComponent, which provides an iterator (over the
        underlying indexing set).
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def dimen(self):
        ...
    
    @property
    def domain(self):
        ...
    
    def ranges(self):
        ...
    
    def bounds(self): # -> tuple[None, None] | tuple[int | Any | None, int | Any | None]:
        ...
    
    def get_interval(self): # -> tuple[None, ...] | tuple[int | Any | None, ...] | tuple[Any | None, Any | None, Any] | tuple[Any, Any, Literal[0]] | tuple[Any, Any, Any] | tuple[float | Any | None, float | Any | None, int]:
        """Return the interval for this Set as (start, end, step)

        Returns the effective interval for this Set as a (start, end,
        step) tuple.  Start and End are the same as returned by
        `bounds()`.  Step is 0 for continuous ranges, a positive value
        for regular discrete sets (e.g., 1 for Integers), or `None` for
        Sets that do not have a regular interval (e.g., semicontinuous
        sets, mixed type sets, sets with dimen != 1, etc).

        """
        ...
    
    @property
    @deprecated("The 'virtual' attribute is no longer supported", version='5.7')
    def virtual(self): # -> bool:
        ...
    
    @virtual.setter
    def virtual(self, value): # -> None:
        ...
    
    @property
    @deprecated("The 'concrete' attribute is no longer supported.  " "Use isdiscrete() or isfinite()", version='5.7')
    def concrete(self): # -> Literal[False]:
        ...
    
    @concrete.setter
    def concrete(self, value): # -> None:
        ...
    
    @property
    @deprecated("The 'ordered' attribute is no longer supported.  Use isordered()", version='5.7')
    def ordered(self): # -> Literal[False]:
        ...
    
    @property
    @deprecated("'filter' is no longer a public attribute.", version='5.7')
    def filter(self): # -> None:
        ...
    
    @deprecated("check_values() is deprecated: Sets only contain valid members", version='5.7')
    def check_values(self): # -> Literal[True]:
        """
        Verify that the values in this set are valid.
        """
        ...
    
    def isdisjoint(self, other): # -> bool | None:
        """Test if this Set is disjoint from `other`

        Parameters
        ----------
            other : ``Set`` or ``iterable``
                The Set or iterable object to compare this Set against

        Returns
        -------
        bool : True if this set is disjoint from `other`
        """
        ...
    
    def issubset(self, other): # -> bool:
        """Test if this Set is a subset of `other`

        Parameters
        ----------
            other : ``Set`` or ``iterable``
                The Set or iterable object to compare this Set against

        Returns
        -------
        bool : True if this set is a subset of `other`
        """
        ...
    
    def issuperset(self, other): # -> bool:
        """Test if this Set is a superset of `other`

        Parameters
        ----------
            other : ``Set`` or ``iterable``
                The Set or iterable object to compare this Set against

        Returns
        -------
        bool : True if this set is a superset of `other`
        """
        ...
    
    def union(self, *args): # -> Self | SetUnion | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        """
        Return the union of this set with one or more sets.
        """
        ...
    
    def intersection(self, *args): # -> Self | SetIntersection | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        """
        Return the intersection of this set with one or more sets
        """
        ...
    
    def difference(self, *args): # -> Self | SetDifference | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        """
        Return the difference between this set with one or more sets
        """
        ...
    
    def symmetric_difference(self, other): # -> SetSymmetricDifference | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        """
        Return the symmetric difference of this set with another set
        """
        ...
    
    def cross(self, *args): # -> SetProduct | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        """
        Return the cross-product between this set and one or more sets
        """
        ...
    
    __le__ = ...
    __ge__ = ...
    __or__ = ...
    __and__ = ...
    __sub__ = ...
    __xor__ = ...
    __mul__ = ...
    def __ror__(self, other): # -> SetUnion | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def __rand__(self, other): # -> SetIntersection | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def __rsub__(self, other): # -> SetDifference | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def __rxor__(self, other): # -> SetSymmetricDifference | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def __rmul__(self, other): # -> SetProduct | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def __lt__(self, other) -> bool:
        """
        Return True if the set is a strict subset of 'other'
        """
        ...
    
    def __gt__(self, other) -> bool:
        """
        Return True if the set is a strict superset of 'other'
        """
        ...
    


class _SetData(metaclass=RenamedClass):
    __renamed__new_class__ = SetData
    __renamed__version__ = ...


class _SetDataBase(metaclass=RenamedClass):
    __renamed__new_class__ = SetData
    __renamed__version__ = ...


class _FiniteSetMixin:
    __slots__ = ...
    def __len__(self):
        ...
    
    def __iter__(self):
        """Iterate over the finite set

        Note: derived classes should NOT reimplement this method, and
        should instead overload _iter_impl.  The expression template
        system relies on being able to replace this method for all Sets
        during template generation.

        """
        ...
    
    def __reversed__(self): # -> Iterator[Any]:
        ...
    
    def sorted_iter(self): # -> Iterator[Any]:
        ...
    
    def ordered_iter(self): # -> Iterator[Any]:
        ...
    
    def isdiscrete(self): # -> Literal[True]:
        """Returns True if this set admits only discrete members"""
        ...
    
    def isfinite(self): # -> Literal[True]:
        """Returns True if this is a finite discrete (iterable) Set"""
        ...
    
    def data(self): # -> tuple[Any, ...]:
        ...
    
    @property
    @deprecated("The 'value' attribute is deprecated.  Use .data() to " "retrieve the values in a finite set.", version='5.7')
    def value(self): # -> set[Any]:
        ...
    
    @property
    @deprecated("The 'value_list' attribute is deprecated.  Use " ".ordered_data() to retrieve the values from a finite set " "in a deterministic order.", version='5.7')
    def value_list(self): # -> list[Any]:
        ...
    
    def sorted_data(self): # -> tuple[Any, ...]:
        ...
    
    def ordered_data(self): # -> tuple[Any, ...]:
        ...
    
    def bounds(self): # -> tuple[None, None] | tuple[Any | None, Any | None]:
        ...
    
    def ranges(self): # -> Generator[NumericRange | NonNumericRange, Any, None]:
        ...
    


class FiniteSetData(_FiniteSetMixin, SetData):
    """A general unordered iterable Set"""
    __slots__ = ...
    def __init__(self, component) -> None:
        ...
    
    def get(self, value, default=...): # -> None:
        """
        Return True if the set contains a given value.

        This method will raise TypeError for unhashable types.
        """
        ...
    
    def __reversed__(self): # -> reversed[Any] | Iterator[Any]:
        ...
    
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def dimen(self): # -> type[UnknownSetDimen] | int:
        ...
    
    @property
    def domain(self):
        ...
    
    @property
    @deprecated("'filter' is no longer a public attribute.", version='5.7')
    def filter(self):
        ...
    
    def add(self, *values): # -> int:
        ...
    
    def remove(self, val): # -> None:
        ...
    
    def discard(self, val): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def set_value(self, val): # -> None:
        ...
    
    def update(self, values): # -> None:
        ...
    
    def pop(self):
        ...
    


class _FiniteSetData(metaclass=RenamedClass):
    __renamed__new_class__ = FiniteSetData
    __renamed__version__ = ...


class _ScalarOrderedSetMixin:
    __slots__ = ...
    def values(self): # -> Generator[Self, Any, None]:
        """Return an iterator of the component data objects in the dictionary"""
        ...
    
    def items(self): # -> Generator[tuple[Any, Self], Any, None]:
        """Return an iterator of (index,data) tuples from the dictionary"""
        ...
    


class _OrderedSetMixin:
    __slots__ = ...
    _valid_getitem_keys = ...
    def at(self, index):
        ...
    
    def ord(self, val):
        ...
    
    def __getitem__(self, key):
        ...
    
    @deprecated("card() was incorrectly added to the Set API.  Please use at()", version='6.1.2', remove_in='6.2')
    def card(self, index):
        ...
    
    def isordered(self): # -> Literal[True]:
        """Returns True if this is an ordered finite discrete (iterable) Set"""
        ...
    
    def ordered_data(self):
        ...
    
    def ordered_iter(self): # -> Iterator[Any]:
        ...
    
    def first(self):
        ...
    
    def last(self): # -> _T:
        ...
    
    def next(self, item, step=...):
        """
        Return the next item in the set.

        The default behavior is to return the very next element. The `step`
        option can specify how many steps are taken to get the next element.

        If the search item is not in the Set, or the next element is beyond
        the end of the set, then an IndexError is raised.
        """
        ...
    
    def nextw(self, item, step=...):
        """
        Return the next item in the set with wrapping if necessary.

        The default behavior is to return the very next element. The `step`
        option can specify how many steps are taken to get the next element.
        If the next element is past the end of the Set, the search wraps back
        to the beginning of the Set.

        If the search item is not in the Set an IndexError is raised.
        """
        ...
    
    def prev(self, item, step=...):
        """Return the previous item in the set.

        The default behavior is to return the immediately previous
        element. The `step` option can specify how many steps are taken
        to get the previous element.

        If the search item is not in the Set, or the previous element is
        before the beginning of the set, then an IndexError is raised.
        """
        ...
    
    def prevw(self, item, step=...):
        """Return the previous item in the set with wrapping if necessary.

        The default behavior is to return the immediately
        previouselement. The `step` option can specify how many steps
        are taken to get the previous element. If the previous element
        is past the end of the Set, the search wraps back to the end of
        the Set.

        If the search item is not in the Set an IndexError is raised.
        """
        ...
    


class OrderedSetData(_OrderedSetMixin, FiniteSetData):
    """
    This class defines the base class for an ordered set of concrete data.

    In older Pyomo terms, this defines a "concrete" ordered set - that is,
    a set that "owns" the list of set members.  While this class actually
    implements a set ordered by insertion order, we make the "official"
    InsertionOrderSetData an empty derivative class, so that

         issubclass(SortedSetData, InsertionOrderSetData) == False

    Constructor Arguments:
        component   The Set object that owns this data.

    Public Class Attributes:
    """
    __slots__ = ...
    def __init__(self, component) -> None:
        ...
    
    def __reversed__(self): # -> Iterator[Any]:
        ...
    
    def remove(self, val): # -> None:
        ...
    
    def discard(self, val): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def pop(self): # -> _T:
        ...
    
    def at(self, index):
        """
        Return the specified member of the set.

        The public Set API is 1-based, even though the
        internal _lookup and _values are (pythonically) 0-based.
        """
        ...
    
    def ord(self, item):
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class _OrderedSetData(metaclass=RenamedClass):
    __renamed__new_class__ = OrderedSetData
    __renamed__version__ = ...


class InsertionOrderSetData(OrderedSetData):
    """
    This class defines the data for a ordered set where the items are ordered
    in insertion order (similar to Python's OrderedSet.

    Constructor Arguments:
        component   The Set object that owns this data.

    Public Class Attributes:
    """
    __slots__ = ...
    def set_value(self, val): # -> None:
        ...
    
    def update(self, values): # -> None:
        ...
    


class _InsertionOrderSetData(metaclass=RenamedClass):
    __renamed__new_class__ = InsertionOrderSetData
    __renamed__version__ = ...


class _SortedSetMixin:
    """"""
    __slots__ = ...
    def ordered_iter(self):
        ...
    
    def sorted_iter(self):
        ...
    


class SortedSetData(_SortedSetMixin, OrderedSetData):
    """
    This class defines the data for a sorted set.

    Constructor Arguments:
        component   The Set object that owns this data.

    Public Class Attributes:
    """
    __slots__ = ...
    def __reversed__(self): # -> reversed[Any]:
        ...
    
    def sorted_data(self): # -> tuple[Any, ...]:
        ...
    


class _SortedSetData(metaclass=RenamedClass):
    __renamed__new_class__ = SortedSetData
    __renamed__version__ = ...


_SET_API = ...
_FINITESET_API = ...
_ORDEREDSET_API = ...
_SETDATA_API = ...
@ModelComponentFactory.register("Set data that is used to define a model instance.")
class Set(IndexedComponent):
    """A component used to index other Pyomo components.

    This class provides a Pyomo component that is API-compatible with
    Python `set` objects, with additional features, including:

        1. Member validation and filtering.  The user can declare
           domains and provide callback functions to validate set
           members and to filter (ignore) potential members.
        2. Set expressions.  Operations on Set objects (&,|,*,-,^)
           produce Set expressions that preserve their references to the
           original Set objects so that updating the argument Sets
           implicitly updates the Set operator instance.
        3. Support for set operations with RangeSet instances (both
           finite and non-finite ranges).

    Parameters
    ----------
    initialize : initializer(iterable), optional
        The initial values to store in the Set when it is
        constructed.  Values passed to ``initialize`` may be
        overridden by ``data`` passed to the :py:meth:`construct`
        method.

    dimen : initializer(int), optional
        Specify the Set's arity (the required tuple length for all
        members of the Set), or None if no arity is enforced

    ordered : bool or Set.InsertionOrder or Set.SortedOrder or function
        Specifies whether the set is ordered.
        Possible values are:

          ======================  =====================================
          ``False``               Unordered
          ``True``                Ordered by insertion order
          ``Set.InsertionOrder``  Ordered by insertion order [default]
          ``Set.SortedOrder``     Ordered by sort order
          ``<function>``          Ordered with this comparison function
          ======================  =====================================

    within : initialiser(set), optional
        A set that defines the valid values that can be contained
        in this set. If the latter is indexed, the former can be indexed or
        non-indexed, in which case it applies to all indices.
    domain : initializer(set), optional
        A set that defines the valid values that can be contained
        in this set
    bounds : initializer(tuple), optional
        A tuple that specifies the bounds for valid Set values
        (accepts 1-, 2-, or 3-tuple RangeSet arguments)
    filter : initializer(rule), optional
        A rule for determining membership in this set. This has the
        functional form:

            ``f: Block, *data -> bool``

        and returns True if the data belongs in the set.  Set will
        quietly ignore any values where `filter` returns False.
    validate : initializer(rule), optional
        A rule for validating membership in this set. This has the
        functional form:

            ``f: Block, *data -> bool``

        and returns True if the data belongs in the set.  Set will
        raise a ``ValueError`` for any values where `validate`
        returns False.

    name : str, optional
        The name of the set

    doc : str, optional
        A text string describing this component

    Notes
    -----
      .. note::

        ``domain=``, ``within=``, and ``bounds=`` all provide
        restrictions on the valid set values.  If more than one is
        specified, Set values will be restricted to the intersection of
        ``domain``, ``within``, and ``bounds``.

    """
    class _SetEndException(Exception):
        ...
    
    
    class _SetEndType(type):
        def __hash__(self) -> int:
            ...
        
    
    
    class End(metaclass=_SetEndType):
        ...
    
    
    class InsertionOrder:
        ...
    
    
    class SortedOrder:
        ...
    
    
    _ValidOrderedArguments = ...
    _UnorderedInitializers = ...
    @overload
    def __new__(cls: Type[Set], *args, **kwds) -> Union[SetData, IndexedSet]:
        ...
    
    @overload
    def __new__(cls: Type[OrderedScalarSet], *args, **kwds) -> OrderedScalarSet:
        ...
    
    def __new__(cls, *args, **kwds): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    @overload
    def __init__(self, *indexes, initialize=..., dimen=..., ordered=..., within=..., domain=..., bounds=..., filter=..., validate=..., name=..., doc=...) -> None:
        ...
    
    def __init__(self, *args, **kwds) -> None:
        ...
    
    @deprecated("check_values() is deprecated: Sets only contain valid members", version='5.7')
    def check_values(self): # -> Literal[True]:
        """
        Verify that the values in this set are valid.
        """
        ...
    
    def construct(self, data=...): # -> None:
        ...
    


class IndexedSet(Set):
    def data(self): # -> dict[Any | None, Any]:
        "Return a dict containing the data() of each Set in this IndexedSet"
        ...
    
    @overload
    def __getitem__(self, index) -> SetData:
        ...
    
    __getitem__ = ...


class FiniteScalarSet(FiniteSetData, Set):
    def __init__(self, **kwds) -> None:
        ...
    


class FiniteSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = FiniteScalarSet
    __renamed__version__ = ...


class OrderedScalarSet(_ScalarOrderedSetMixin, InsertionOrderSetData, Set):
    def __init__(self, **kwds) -> None:
        ...
    


class OrderedSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = OrderedScalarSet
    __renamed__version__ = ...


class SortedScalarSet(_ScalarOrderedSetMixin, SortedSetData, Set):
    def __init__(self, **kwds) -> None:
        ...
    


class SortedSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = SortedScalarSet
    __renamed__version__ = ...


@disable_methods(_FINITESET_API + _SETDATA_API)
class AbstractFiniteScalarSet(FiniteScalarSet):
    ...


class AbstractFiniteSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractFiniteScalarSet
    __renamed__version__ = ...


@disable_methods(_ORDEREDSET_API + _SETDATA_API)
class AbstractOrderedScalarSet(OrderedScalarSet):
    ...


class AbstractOrderedSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractOrderedScalarSet
    __renamed__version__ = ...


@disable_methods(_ORDEREDSET_API + _SETDATA_API)
class AbstractSortedScalarSet(SortedScalarSet):
    ...


class AbstractSortedSimpleSet(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractSortedScalarSet
    __renamed__version__ = ...


class SetOf(SetData, Component):
    """"""
    def __new__(cls, *args, **kwds): # -> Self | OrderedSetOf | FiniteSetOf | InfiniteSetOf:
        ...
    
    def __init__(self, reference, **kwds) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def construct(self, data=...): # -> None:
        ...
    
    @property
    def dimen(self): # -> int | None:
        ...
    
    @property
    def domain(self): # -> Self:
        ...
    


class InfiniteSetOf(SetOf):
    def ranges(self):
        ...
    


class FiniteSetOf(_FiniteSetMixin, SetOf):
    def get(self, value, default=...): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __reversed__(self): # -> Iterator[Any]:
        ...
    


class UnorderedSetOf(metaclass=RenamedClass):
    __renamed__new_class__ = FiniteSetOf
    __renamed__version__ = ...


class OrderedSetOf(_ScalarOrderedSetMixin, _OrderedSetMixin, FiniteSetOf):
    def at(self, index):
        ...
    
    def ord(self, item):
        ...
    


class InfiniteRangeSetData(SetData):
    """Data class for a infinite set.

    This Set implements an interface to an *infinite set* defined by one
    or more NumericRange objects.  As there are an infinite
    number of members, Infinite Range Sets are not iterable.

    """
    __slots__ = ...
    def __init__(self, component) -> None:
        ...
    
    def get(self, value, default=...): # -> None:
        ...
    
    def isdiscrete(self): # -> bool:
        """Returns True if this set admits only discrete members"""
        ...
    
    @property
    def dimen(self): # -> Literal[1]:
        ...
    
    @property
    def domain(self):
        ...
    
    def clear(self): # -> None:
        ...
    
    def ranges(self):
        ...
    


class _InfiniteRangeSetData(metaclass=RenamedClass):
    __renamed__new_class__ = InfiniteRangeSetData
    __renamed__version__ = ...


class FiniteRangeSetData(_SortedSetMixin, _OrderedSetMixin, _FiniteSetMixin, InfiniteRangeSetData):
    __slots__ = ...
    def __len__(self): # -> int:
        ...
    
    def at(self, index):
        ...
    
    def ord(self, item): # -> int:
        ...
    
    bounds = ...
    ranges = ...
    domain = ...


class _FiniteRangeSetData(metaclass=RenamedClass):
    __renamed__new_class__ = FiniteRangeSetData
    __renamed__version__ = ...


@ModelComponentFactory.register("A sequence of numeric values.  RangeSet(start,end,step) is a sequence " "starting a value 'start', and increasing in values by 'step' until a " "value greater than or equal to 'end' is reached.")
class RangeSet(Component):
    """A set object that represents a set of numeric values

    `RangeSet` objects are based around `NumericRange` objects, which
    include support for non-finite ranges (both continuous and
    unbounded). Similarly, boutique ranges (like semi-continuous
    domains) can be represented, e.g.:

    .. doctest::

       >>> from pyomo.core.base.range import NumericRange
       >>> from pyomo.environ import RangeSet
       >>> print(RangeSet(ranges=(NumericRange(0,0,0), NumericRange(1,100,0))))
       ([0] | [1..100])

    The `RangeSet` object continues to support the notation for
    specifying discrete ranges using "[first=1], last, [step=1]" values:

    .. doctest::

        >>> r = RangeSet(3)
        >>> print(r)
        [1:3]
        >>> print(list(r))
        [1, 2, 3]

        >>> r = RangeSet(2, 5)
        >>> print(r)
        [2:5]
        >>> print(list(r))
        [2, 3, 4, 5]

        >>> r = RangeSet(2, 5, 2)
        >>> print(r)
        [2:4:2]
        >>> print(list(r))
        [2, 4]

        >>> r = RangeSet(2.5, 4, 0.5)
        >>> print(r)
        ([2.5] | [3.0] | [3.5] | [4.0])
        >>> print(list(r))
        [2.5, 3.0, 3.5, 4.0]

    By implementing RangeSet using NumericRanges, the global Sets (like
    `Reals`, `Integers`, `PositiveReals`, etc.) are trivial
    instances of a RangeSet and support all Set operations.

    Parameters
    ----------
    *args: int | float | None
        The range defined by ([start=1], end, [step=1]).  If only a
        single positional parameter, `end` is supplied, then the
        RangeSet will be the integers starting at 1 up through and
        including end.  Providing two positional arguments, `x` and `y`,
        will result in a range starting at x up to and including y,
        incrementing by 1.  Providing a 3-tuple enables the
        specification of a step other than 1.

    finite: bool, optional
        This sets if this range is finite (discrete and bounded) or infinite

    ranges: iterable, optional
        The list of range objects that compose this RangeSet

    bounds: tuple, optional
        The lower and upper bounds of values that are admissible in this
        RangeSet

    filter: function, optional
        Function (rule) that returns True if the specified value is in
        the RangeSet or False if it is not.

    validate: function, optional
        Data validation function (rule).  The function will be called
        for every data member of the set, and if it returns False, a
        ValueError will be raised.

    name: str, optional
        Name for this component.

    doc: str, optional
        Text describing this component.
    """
    def __new__(cls, *args, **kwds): # -> Self | AbstractFiniteScalarRangeSet | AbstractInfiniteScalarRangeSet:
        ...
    
    @overload
    def __init__(self, _end, *, finite=..., ranges=..., bounds=..., filter=..., validate=..., name=..., doc=...) -> None:
        ...
    
    @overload
    def __init__(self, _start, _end, _step=..., *, finite=..., ranges=..., bounds=..., filter=..., validate=..., name=..., doc=...) -> None:
        ...
    
    @overload
    def __init__(self, *, finite=..., ranges=..., bounds=..., filter=..., validate=..., name=..., doc=...) -> None:
        ...
    
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def construct(self, data=...):
        ...
    
    def dim(self): # -> Literal[0]:
        ...
    
    def index_set(self): # -> _UnindexedComponent_set:
        ...
    


class InfiniteScalarRangeSet(InfiniteRangeSetData, RangeSet):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    __str__ = ...


class InfiniteSimpleRangeSet(metaclass=RenamedClass):
    __renamed__new_class__ = InfiniteScalarRangeSet
    __renamed__version__ = ...


class FiniteScalarRangeSet(_ScalarOrderedSetMixin, FiniteRangeSetData, RangeSet):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    __str__ = ...


class FiniteSimpleRangeSet(metaclass=RenamedClass):
    __renamed__new_class__ = FiniteScalarRangeSet
    __renamed__version__ = ...


@disable_methods(_SET_API)
class AbstractInfiniteScalarRangeSet(InfiniteScalarRangeSet):
    ...


class AbstractInfiniteSimpleRangeSet(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractInfiniteScalarRangeSet
    __renamed__version__ = ...


@disable_methods(_ORDEREDSET_API)
class AbstractFiniteScalarRangeSet(FiniteScalarRangeSet):
    ...


class AbstractFiniteSimpleRangeSet(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractFiniteScalarRangeSet
    __renamed__version__ = ...


class SetOperator(SetData, Set):
    __slots__ = ...
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def construct(self, data=...): # -> None:
        ...
    
    def __len__(self):
        """Return the length of this Set

        Because Set objects (and therefore SetOperator objects) are a
        subclass of IndexedComponent, we need to override the definition
        of len() to return the length of the Set and not the Component.
        Failing to do so would result in scalar infinite set operators
        to return a length of "1".

        Python requires len() to return a nonnegatie integer.  Instead
        of returning `float('inf')` here and allowing Python to raise
        the OverflowError, we will raise it directly here where we can
        provide a more informative error message.

        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def isdiscrete(self): # -> bool:
        """Returns True if this set admits only discrete members"""
        ...
    
    def subsets(self, expand_all_set_operators=...): # -> Generator[SetOperator | Any, Any, None]:
        ...
    
    @property
    @deprecated("SetProduct.set_tuple is deprecated.  " "Use SetProduct.subsets() to get the operator arguments.", version='5.7')
    def set_tuple(self): # -> list[SetOperator | Any]:
        ...
    
    @property
    def domain(self): # -> Self:
        ...
    


class SetUnion(SetOperator):
    __slots__ = ...
    _operator = ...
    def __new__(cls, *args): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def ranges(self): # -> chain[Any]:
        ...
    
    @property
    def dimen(self): # -> type[UnknownSetDimen] | Any | None:
        ...
    


class SetUnion_InfiniteSet(SetUnion):
    __slots__ = ...
    def get(self, val, default=...): # -> Any | None:
        ...
    


class SetUnion_FiniteSet(_FiniteSetMixin, SetUnion_InfiniteSet):
    __slots__ = ...
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    


class SetUnion_OrderedSet(_ScalarOrderedSetMixin, _OrderedSetMixin, SetUnion_FiniteSet):
    __slots__ = ...
    def at(self, index): # -> Any:
        ...
    
    def ord(self, item): # -> Any | int:
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class SetIntersection(SetOperator):
    __slots__ = ...
    _operator = ...
    def __new__(cls, *args): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def construct(self, data=...): # -> None:
        ...
    
    def ranges(self): # -> Generator[Any, Any, None]:
        ...
    
    @property
    def dimen(self): # -> Any | type[UnknownSetDimen] | Literal[0]:
        ...
    


class SetIntersection_InfiniteSet(SetIntersection):
    __slots__ = ...
    def get(self, val, default=...): # -> Any | None:
        ...
    


class SetIntersection_FiniteSet(_FiniteSetMixin, SetIntersection_InfiniteSet):
    __slots__ = ...
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    


class SetIntersection_OrderedSet(_ScalarOrderedSetMixin, _OrderedSetMixin, SetIntersection_FiniteSet):
    __slots__ = ...
    def at(self, index):
        ...
    
    def ord(self, item): # -> int:
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class SetDifference(SetOperator):
    __slots__ = ...
    _operator = ...
    def __new__(cls, *args): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def ranges(self): # -> Generator[Any, Any, None]:
        ...
    
    @property
    def dimen(self): # -> Any:
        ...
    


class SetDifference_InfiniteSet(SetDifference):
    __slots__ = ...
    def get(self, val, default=...): # -> Any | None:
        ...
    


class SetDifference_FiniteSet(_FiniteSetMixin, SetDifference_InfiniteSet):
    __slots__ = ...
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    


class SetDifference_OrderedSet(_ScalarOrderedSetMixin, _OrderedSetMixin, SetDifference_FiniteSet):
    __slots__ = ...
    def at(self, index):
        ...
    
    def ord(self, item): # -> int:
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class SetSymmetricDifference(SetOperator):
    __slots__ = ...
    _operator = ...
    def __new__(cls, *args): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def ranges(self): # -> Generator[Any, Any, None]:
        ...
    
    @property
    def dimen(self): # -> type[UnknownSetDimen] | Any | None:
        ...
    


class SetSymmetricDifference_InfiniteSet(SetSymmetricDifference):
    __slots__ = ...
    def get(self, val, default=...): # -> Any | None:
        ...
    


class SetSymmetricDifference_FiniteSet(_FiniteSetMixin, SetSymmetricDifference_InfiniteSet):
    __slots__ = ...
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    


class SetSymmetricDifference_OrderedSet(_ScalarOrderedSetMixin, _OrderedSetMixin, SetSymmetricDifference_FiniteSet):
    __slots__ = ...
    def at(self, index):
        ...
    
    def ord(self, item): # -> int:
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class SetProduct(SetOperator):
    __slots__ = ...
    _operator = ...
    def __new__(cls, *args): # -> Self | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet:
        ...
    
    def ranges(self): # -> Generator[RangeProduct, Any, None]:
        ...
    
    def bounds(self): # -> tuple[Any, Any]:
        ...
    
    @property
    def dimen(self): # -> int | type[UnknownSetDimen] | Any | None:
        ...
    


class SetProduct_InfiniteSet(SetProduct):
    __slots__ = ...
    def get(self, val, default=...): # -> tuple[Any, ...] | tuple[Any] | tuple[Any | tuple[Any, ...] | tuple[Any]] | tuple[Any | tuple[Any, ...] | tuple[Any], ...] | None:
        ...
    


class SetProduct_FiniteSet(_FiniteSetMixin, SetProduct_InfiniteSet):
    __slots__ = ...
    def __len__(self): # -> int:
        """
        Return the number of elements in the set.
        """
        ...
    


class SetProduct_OrderedSet(_ScalarOrderedSetMixin, _OrderedSetMixin, SetProduct_FiniteSet):
    __slots__ = ...
    def at(self, index): # -> tuple[Any, ...] | Any:
        ...
    
    def ord(self, item): # -> Any | int:
        """
        Return the position index of the input value.

        Note that Pyomo Set objects have positions starting at 1 (not 0).

        If the search item is not in the Set, then an IndexError is raised.
        """
        ...
    


class _AnySet(SetData, Set):
    def __init__(self, **kwds) -> None:
        ...
    
    def get(self, val, default=...): # -> None:
        ...
    
    def ranges(self): # -> Generator[AnyRange, Any, None]:
        ...
    
    def bounds(self): # -> tuple[None, None]:
        ...
    
    def clear(self): # -> None:
        ...
    
    def __len__(self):
        ...
    
    @property
    def dimen(self): # -> None:
        ...
    
    @property
    def domain(self):
        ...
    
    def __str__(self) -> str:
        ...
    


class _AnyWithNoneSet(_AnySet):
    @deprecated("The AnyWithNone set is deprecated.  Use Any, which includes None", version='5.7')
    def get(self, val, default=...): # -> None:
        ...
    


class _EmptySet(_FiniteSetMixin, SetData, Set):
    def __init__(self, **kwds) -> None:
        ...
    
    def get(self, val, default=...): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def __len__(self): # -> Literal[0]:
        ...
    
    @property
    def dimen(self): # -> Literal[0]:
        ...
    
    @property
    def domain(self):
        ...
    
    def __str__(self) -> str:
        ...
    


def DeclareGlobalSet(obj, caller_globals=...): # -> RangeSet | AbstractFiniteScalarRangeSet | AbstractInfiniteScalarRangeSet:
    """Declare a copy of a set as a global set in the calling module

    This takes a Set object and declares a duplicate of it as a
    GlobalSet object in the global namespace of the caller's module
    using the local name of the passed set.  GlobalSet objects are
    pseudo-singletons, in that copy.deepcopy (and Model.clone()) will
    not duplcicate them, and when you pickle and restore objects
    containing GlobalSets will still refer to the same object.  The
    declared GlobalSet object will be an instance of the original Set
    type.

    """
    class GlobalSet(GlobalSetBase, obj.__class__):
        ...
    
    

real_global_set_ids = ...
integer_global_set_ids = ...
RealSet = ...
IntegerSet = ...
BinarySet = ...
BooleanSet = ...
@deprecated("RealInterval has been deprecated.  Please use RangeSet(lower, upper, 0)", version='5.7')
class RealInterval(RealSet):
    def __new__(cls, **kwds):
        ...
    


@deprecated("IntegerInterval has been deprecated.  Please use RangeSet(lower, upper, 1)", version='5.7')
class IntegerInterval(IntegerSet):
    def __new__(cls, **kwds):
        ...
    


