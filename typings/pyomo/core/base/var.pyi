"""
This type stub file was generated by pyright.
"""

from pyomo.common.pyomo_typing import overload
from typing import Type, Union
from pyomo.common.deprecation import RenamedClass
from pyomo.core.expr.numvalue import NumericValue, value
from pyomo.core.base.component import ComponentData, ModelComponentFactory
from pyomo.core.base.disable_methods import disable_methods
from pyomo.core.base.indexed_component import IndexedComponent, IndexedComponent_NDArrayMixin

logger = ...
_inf = ...
_ninf = ...
_nonfinite_values = ...
_known_global_real_domains = ...
_VARDATA_API = ...
class VarData(ComponentData, NumericValue):
    """This class defines the data for a single variable."""
    __slots__ = ...
    __autoslot_mappers__ = ...
    def __init__(self, component=...) -> None:
        ...
    
    @classmethod
    def copy(cls, src): # -> Self:
        ...
    
    def set_value(self, val, skip_validation=...): # -> None:
        """Set the current variable value.

        Set the value of this variable.  The incoming value is converted
        to a numeric value (i.e., expressions are evaluated).  If the
        variable has units, the incoming value is converted to the
        correct units before storing the value.  The final value is
        checked against both the variable domain and bounds, and an
        exception is raised if the value is not valid.  Domain and
        bounds checking can be bypassed by setting the ``skip_validation``
        argument to :const:`True`.

        """
        ...
    
    @property
    def value(self): # -> Any | None:
        """Return (or set) the value for this variable."""
        ...
    
    @value.setter
    def value(self, val): # -> None:
        ...
    
    def __call__(self, exception=...): # -> Any | None:
        """Compute the value of this variable."""
        ...
    
    @property
    def domain(self): # -> SetData | Set | AbstractOrderedScalarSet | AbstractSortedScalarSet | AbstractFiniteScalarSet | IndexedSet | None:
        """Return (or set) the domain for this variable."""
        ...
    
    @domain.setter
    def domain(self, domain): # -> None:
        ...
    
    def has_lb(self): # -> bool:
        """Returns :const:`False` when the lower bound is
        :const:`None` or negative infinity"""
        ...
    
    def has_ub(self): # -> bool:
        """Returns :const:`False` when the upper bound is
        :const:`None` or positive infinity"""
        ...
    
    def setlb(self, val): # -> None:
        """
        Set the lower bound for this variable after validating that
        the value is fixed (or None).
        """
        ...
    
    def setub(self, val): # -> None:
        """
        Set the upper bound for this variable after validating that
        the value is fixed (or None).
        """
        ...
    
    @property
    def bounds(self): # -> tuple[int | Any | float | None, int | Any | float | None]:
        """Returns (or set) the tuple (lower bound, upper bound).

        This returns the current (numeric) values of the lower and upper
        bounds as a tuple.  If there is no bound, returns None (and not
        +/-inf)

        """
        ...
    
    @bounds.setter
    def bounds(self, val): # -> None:
        ...
    
    @property
    def lb(self): # -> int | float | None:
        """Return (or set) the numeric value of the variable lower bound."""
        ...
    
    @lb.setter
    def lb(self, val): # -> None:
        ...
    
    @property
    def ub(self): # -> int | float | None:
        """Return (or set) the numeric value of the variable upper bound."""
        ...
    
    @ub.setter
    def ub(self, val): # -> None:
        ...
    
    @property
    def lower(self): # -> int | NPV_MaxExpression | None:
        """Return (or set) an expression for the variable lower bound.

        This returns a (not potentially variable) expression for the
        variable lower bound.  This represents the tighter of the
        current domain and the constant or expression assigned to
        :attr:`lower`.  Note that the expression will NOT automatically
        reflect changes to either the domain or the bound expression
        (e.g., because of assignment to either :attr:`lower` or
        :attr:`domain`).

        """
        ...
    
    @lower.setter
    def lower(self, val): # -> None:
        ...
    
    @property
    def upper(self): # -> int | NPV_MinExpression | None:
        """Return (or set) an expression for the variable upper bound.

        This returns a (not potentially variable) expression for the
        variable upper bound.  This represents the tighter of the
        current domain and the constant or expression assigned to
        :attr:`upper`.  Note that the expression will NOT automatically
        reflect changes to either the domain or the bound expression
        (e.g., because of assignment to either :attr:`upper` or
        :attr:`domain`).

        """
        ...
    
    @upper.setter
    def upper(self, val): # -> None:
        ...
    
    def get_units(self):
        """Return the units for this variable entry."""
        ...
    
    def fix(self, value=..., skip_validation=...): # -> None:
        """Fix the value of this variable (treat as nonvariable)

        This sets the :attr:`fixed` indicator to True.  If ``value`` is
        provided, the value (and the ``skip_validation`` flag) are first
        passed to :meth:`set_value()`.

        """
        ...
    
    def unfix(self): # -> None:
        """Unfix this variable (treat as variable in solver interfaces)

        This sets the :attr:`fixed` indicator to False.

        """
        ...
    
    def free(self): # -> None:
        """Alias for :meth:`unfix`"""
        ...
    
    @property
    def fixed(self): # -> bool:
        """Return (or set) the fixed indicator for this variable.

        Alias for :meth:`is_fixed` / :meth:`fix` / :meth:`unfix`.

        """
        ...
    
    @fixed.setter
    def fixed(self, val): # -> None:
        ...
    
    @property
    def stale(self): # -> bool:
        """The stale status for this variable.

        Variables are "stale" if their current value was not updated as
        part of the most recent model update.  A "model update" can be
        one of several things: a solver invocation, loading a previous
        solution, or manually updating a non-stale :class:`Var` value.

        Returns
        -------
        bool

        Notes
        -----
        Fixed :class:`Var` objects will be stale after invoking a solver
        (as their value was not updated by the solver).

        Updating a stale :class:`Var` value will not cause other
        variable values to be come stale.  However, updating the first
        non-stale :class:`Var` value after a solve or solution load
        *will* cause all other variables to be marked as stale

        """
        ...
    
    @stale.setter
    def stale(self, val): # -> None:
        ...
    
    def is_integer(self): # -> bool | Any:
        """Returns True when the domain is a contiguous integer range."""
        ...
    
    def is_binary(self): # -> bool:
        """Returns True when the domain is restricted to Binary values."""
        ...
    
    def is_continuous(self): # -> bool | Any:
        """Returns True when the domain is a continuous real range"""
        ...
    
    def is_fixed(self): # -> bool:
        """Returns True if this variable is fixed, otherwise returns False."""
        ...
    
    def is_constant(self): # -> Literal[False]:
        """Returns False because this is not a constant in an expression."""
        ...
    
    def is_variable_type(self): # -> Literal[True]:
        """Returns True because this is a variable."""
        ...
    
    def is_potentially_variable(self): # -> Literal[True]:
        """Returns True because this is a variable."""
        ...
    
    def clear(self): # -> None:
        ...
    


class _VarData(metaclass=RenamedClass):
    __renamed__new_class__ = VarData
    __renamed__version__ = ...


class _GeneralVarData(metaclass=RenamedClass):
    __renamed__new_class__ = VarData
    __renamed__version__ = ...


@ModelComponentFactory.register("Decision variables.")
class Var(IndexedComponent, IndexedComponent_NDArrayMixin):
    """A numeric variable, which may be defined over an index.

    Args:
        domain (Set or function, optional): A Set that defines valid
            values for the variable (e.g., ``Reals``, ``NonNegativeReals``,
            ``Binary``), or a rule that returns Sets.  Defaults to ``Reals``.
        within (Set or function, optional): An alias for ``domain``.
        bounds (tuple or function, optional): A tuple of ``(lower, upper)``
            bounds for the variable, or a rule that returns tuples.
            Defaults to ``(None, None)``.
        initialize (float or function, optional): The initial value for
            the variable, or a rule that returns initial values.
        rule (float or function, optional): An alias for ``initialize``.
        dense (bool, optional): Instantiate all elements from
            :meth:`index_set` when constructing the Var (True) or just the
            variables returned by ``initialize``/``rule`` (False).  Defaults
            to ``True``.
        units (pyomo units expression, optional): Set the units corresponding
            to the entries in this variable.
        name (str, optional): Name for this component.
        doc (str, optional): Text describing this component.
    """
    _ComponentDataClass = VarData
    @overload
    def __new__(cls: Type[Var], *args, **kwargs) -> Union[ScalarVar, IndexedVar]:
        ...
    
    @overload
    def __new__(cls: Type[ScalarVar], *args, **kwargs) -> ScalarVar:
        ...
    
    @overload
    def __new__(cls: Type[IndexedVar], *args, **kwargs) -> IndexedVar:
        ...
    
    def __new__(cls, *args, **kwargs): # -> Self | AbstractScalarVar | IndexedVar:
        ...
    
    @overload
    def __init__(self, *indexes, domain=..., within=..., bounds=..., initialize=..., rule=..., dense=..., units=..., name=..., doc=...) -> None:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def flag_as_stale(self): # -> None:
        """
        Set the 'stale' attribute of every variable data object to True.
        """
        ...
    
    def get_values(self, include_fixed_values=...): # -> dict[Any, Any]:
        """
        Return a dictionary of index-value pairs.
        """
        ...
    
    extract_values = ...
    def set_values(self, new_values, skip_validation=...): # -> None:
        """
        Set the values of a dictionary.

        The default behavior is to validate the values in the
        dictionary.
        """
        ...
    
    def get_units(self): # -> _PyomoUnit:
        """Return the units expression for this Var."""
        ...
    
    def add(self, index): # -> ComponentData:
        """Add a variable with a particular index."""
        ...
    
    def construct(self, data=...):
        """
        Construct the VarData objects for this variable
        """
        ...
    


class ScalarVar(VarData, Var):
    """A single variable."""
    def __init__(self, *args, **kwd) -> None:
        ...
    


@disable_methods(_VARDATA_API)
class AbstractScalarVar(ScalarVar):
    ...


class SimpleVar(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarVar
    __renamed__version__ = ...


class IndexedVar(Var):
    """An array of variables."""
    def setlb(self, val): # -> None:
        """
        Set the lower bound for this variable.
        """
        ...
    
    def setub(self, val): # -> None:
        """
        Set the upper bound for this variable.
        """
        ...
    
    def fix(self, value=..., skip_validation=...): # -> None:
        """Fix all variables in this :class:`IndexedVar` (treat as nonvariable)

        This sets the :attr:`fixed` indicator to True for every variable
        in this IndexedVar.  If ``value`` is provided, the value (and
        the ``skip_validation`` flag) are first passed to
        :meth:`set_value`.

        """
        ...
    
    def unfix(self): # -> None:
        """Unfix all variables in this :class:`IndexedVar` (treat as variable)

        This sets the :attr:`VarData.fixed` indicator to False for
        every variable in this :class:`IndexedVar`.

        """
        ...
    
    def free(self): # -> None:
        """Alias for :meth:`unfix`"""
        ...
    
    @property
    def domain(self):
        ...
    
    @domain.setter
    def domain(self, domain): # -> None:
        """Sets the domain for all variables in this container."""
        ...
    
    def __getitem__(self, args) -> VarData:
        ...
    


@ModelComponentFactory.register("List of decision variables.")
class VarList(IndexedVar):
    """
    Variable-length indexed variable objects used to construct Pyomo models.
    """
    def __init__(self, **kwargs) -> None:
        ...
    
    def construct(self, data=...): # -> None:
        """Construct this component."""
        ...
    
    def add(self): # -> VarData:
        """Add a variable to this list."""
        ...
    


