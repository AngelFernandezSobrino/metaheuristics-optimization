"""
This type stub file was generated by pyright.
"""

from pyomo.common.autoslots import AutoSlots

_inf = ...
_infinite = ...
class RangeDifferenceError(ValueError):
    ...


class NumericRange(AutoSlots.Mixin):
    """A representation of a numeric range.

    This class represents a contiguous range of numbers.  The class
    mimics the Pyomo (*not* Python) `range` API, with a Start, End, and
    Step.  The Step is a signed int.  If the Step is 0, the range is
    continuous.  The End *is* included in the range.  Ranges are closed,
    unless `closed` is specified as a 2-tuple of bool values.  Only
    continuous ranges may be open (or partially open)

    Closed ranges are not necessarily strictly finite, as None is
    allowed for the End value (as well as the Start value, for
    continuous ranges only).

    Parameters
    ----------
        start : float
            The starting value for this NumericRange
        end : float
            The last value for this NumericRange
        step : int
            The interval between values in the range.  0 indicates a
            continuous range.  Negative values indicate discrete ranges
            walking backwards.
        closed : tuple of bool, optional
            A 2-tuple of bool values indicating if the beginning and end
            of the range is closed.  Open ranges are only allowed for
            continuous NumericRange objects.
    """
    __slots__ = ...
    _EPS = ...
    _types_comparable_to_int = ...
    _closedMap = ...
    def __init__(self, start, end, step, closed=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __contains__(self, value): # -> bool:
        ...
    
    def isdiscrete(self): # -> int | bool:
        ...
    
    def isfinite(self): # -> bool:
        ...
    
    def isdisjoint(self, other): # -> bool:
        ...
    
    def issubset(self, other): # -> bool:
        ...
    
    def normalize_bounds(self): # -> tuple[float | Any, float | Any, tuple[bool, bool]]:
        """Normalizes this NumericRange.

        This returns a normalized range by reversing lb and ub if the
        NumericRange step is less than zero.  If lb and ub are
        reversed, then closed is updated to reflect that change.

        Returns
        -------
        lb, ub, closed

        """
        ...
    
    def range_difference(self, other_ranges):
        """Return the difference between this range and a list of other ranges.

        Parameters
        ----------
            other_ranges: `iterable`
                An iterable of other range objects to subtract from this range

        """
        ...
    
    def range_intersection(self, other_ranges): # -> list[Self] | list[Any]:
        """Return the intersection between this range and a set of other ranges.

        Parameters
        ----------
            other_ranges: `iterable`
                An iterable of other range objects to intersect with this range

        """
        ...
    


class NonNumericRange:
    """A range-like object for representing a single non-numeric value

    The class name is a bit of a misnomer, as this object does not
    represent a range but rather a single value.  However, as it
    duplicates the Range API (as used by :py:class:`NumericRange`), it
    is called a "Range".

    """
    __slots__ = ...
    def __init__(self, val) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __contains__(self, value):
        ...
    
    def __getstate__(self): # -> dict[Any, Any]:
        """
        Retrieve the state of this object as a dictionary.

        This method must be defined because this class uses slots.
        """
        ...
    
    def __setstate__(self, state): # -> None:
        """
        Set the state of this object using values from a state dictionary.

        This method must be defined because this class uses slots.
        """
        ...
    
    def isdiscrete(self): # -> Literal[True]:
        ...
    
    def isfinite(self): # -> Literal[True]:
        ...
    
    def isdisjoint(self, other): # -> bool:
        ...
    
    def issubset(self, other): # -> bool:
        ...
    
    def range_difference(self, other_ranges): # -> list[Any] | list[Self]:
        ...
    
    def range_intersection(self, other_ranges): # -> list[Self] | list[Any]:
        ...
    


class AnyRange:
    """A range object for representing Any sets"""
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __contains__(self, value): # -> Literal[True]:
        ...
    
    def isdiscrete(self): # -> Literal[False]:
        ...
    
    def isfinite(self): # -> Literal[False]:
        ...
    
    def isdisjoint(self, other): # -> Literal[False]:
        ...
    
    def issubset(self, other): # -> bool:
        ...
    
    def range_difference(self, other_ranges): # -> list[Any] | list[Self]:
        ...
    
    def range_intersection(self, other_ranges): # -> list[Any]:
        ...
    


class RangeProduct:
    """A range-like object for representing the cross product of ranges"""
    __slots__ = ...
    def __init__(self, range_lists) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __contains__(self, value): # -> bool:
        ...
    
    def __getstate__(self): # -> dict[Any, Any]:
        """
        Retrieve the state of this object as a dictionary.

        This method must be defined because this class uses slots.
        """
        ...
    
    def __setstate__(self, state): # -> None:
        """
        Set the state of this object using values from a state dictionary.

        This method must be defined because this class uses slots.
        """
        ...
    
    def isdiscrete(self): # -> bool:
        ...
    
    def isfinite(self): # -> bool:
        ...
    
    def isdisjoint(self, other): # -> bool:
        ...
    
    def issubset(self, other): # -> bool:
        ...
    
    def range_difference(self, other_ranges): # -> list[Any] | list[Self]:
        ...
    
    def range_intersection(self, other_ranges): # -> list[Any] | list[RangeProduct]:
        ...
    


