"""
This type stub file was generated by pyright.
"""

from pyomo.core.base.component import ActiveComponent, Component, ComponentData
from pyomo.common.deprecation import deprecated

logger = ...
sequence_types = ...
slicer_types = ...
def normalize_index(x): # -> tuple[Any, ...] | tuple[Any]:
    """Normalize a component index.

    This flattens nested sequences into a single tuple.  There is a
    "global" flag (normalize_index.flatten) that will turn off index
    flattening across Pyomo.

    Scalar values will be returned unchanged.  Tuples with a single
    value will be unpacked and returned as a single value.

    Returns
    -------
    scalar or tuple

    """
    ...

class _NotFound:
    ...


class _NotSpecified:
    ...


_rule_returned_none_error = ...
def rule_result_substituter(result_map, map_types): # -> Callable[..., PyomoObject | Any]:
    ...

_map_rule_funcdef = ...
def rule_wrapper(rule, wrapping_fcn, positional_arg_map=..., map_types=...): # -> PyomoObject | Any:
    """Wrap a rule with another function

    This utility method provides a way to wrap a function (rule) with
    another function while preserving the original function signature.
    This is important for rules, as the :py:func:`Initializer`
    argument processor relies on knowing the number of positional
    arguments.

    Parameters
    ----------
    rule: function
        The original rule being wrapped
    wrapping_fcn: function or Dict
        The wrapping function.  The `wrapping_fcn` will be called with
        ``(rule, *args, **kwargs)``.  For convenience, if a `dict` is
        passed as the `wrapping_fcn`, then the result of
        :py:func:`rule_result_substituter(wrapping_fcn)` is used as the
        wrapping function.
    positional_arg_map: iterable[int]
        An iterable of indices of rule positional arguments to expose in
        the wrapped function signature.  For example,
        `positional_arg_map=(2, 0)` and `rule=fcn(a, b, c)` would produce a
        wrapped function with a signature `wrapper_function(c, a)`

    """
    ...

class IndexedComponent(Component):
    """This is the base class for all indexed modeling components.
    This class stores a dictionary, self._data, that maps indices
    to component data objects.  The object self._index_set defines valid
    keys for this dictionary, and the dictionary keys may be a
    strict subset.

    The standard access and iteration methods iterate over the the
    keys of self._data.  This class supports a concept of a default
    component data value.  When enabled, the default does not
    change the access and iteration methods.

    IndexedComponent may be given a set over which indexing is restricted.
    Alternatively, IndexedComponent may be indexed over Any
    (pyomo.core.base.set_types.Any), in which case the IndexedComponent
    behaves like a dictionary - any hashable object can be used as a key
    and keys can be added on the fly.

    Constructor arguments:
        ctype       The class type for the derived subclass
        doc         A text string describing this component

    Private class attributes:

        _data:  A dictionary from the index set to component data objects

        _index_set:  The set of valid indices

        _anonymous_sets: A ComponentSet of "anonymous" sets used by this
            component.  Anonymous sets are Set / SetOperator / RangeSet
            that compose attributes like _index_set, but are not
            themselves explicitly assigned (and named) on any Block

    """
    class Skip:
        ...
    
    
    _DEFAULT_INDEX_CHECKING_ENABLED = ...
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def to_dense_data(self): # -> None:
        """TODO"""
        ...
    
    def clear(self): # -> None:
        """Clear the data in this component"""
        ...
    
    def index_set(self): # -> _UnindexedComponent_set:
        """Return the index set"""
        ...
    
    def is_indexed(self): # -> bool:
        """Return true if this component is indexed"""
        ...
    
    def is_reference(self): # -> bool:
        """Return True if this component is a reference, where
        "reference" is interpreted as any component that does not
        own its own data.
        """
        ...
    
    def dim(self): # -> Literal[0]:
        """Return the dimension of the index"""
        ...
    
    def __len__(self): # -> int:
        """
        Return the number of component data objects stored by this
        component.
        """
        ...
    
    def __contains__(self, idx): # -> bool:
        """Return true if the index is in the dictionary"""
        ...
    
    def __iter__(self): # -> Iterator[Any] | Iterator[None] | filter[None]:
        """Return an iterator of the component data keys"""
        ...
    
    def keys(self, sort=..., ordered=...): # -> Iterator[Any] | Iterator[None] | filter[None]:
        """Return an iterator over the component data keys

        This method sets the ordering of component data objects within
        this IndexedComponent container.  For consistency,
        :py:meth:`__init__()`, :py:meth:`values`, and :py:meth:`items`
        all leverage this method to ensure consistent ordering.

        Parameters
        ----------
        sort: bool or SortComponents
            Iterate over the declared component keys in a specified
            sorted order.  See :py:class:`SortComponents` for valid
            options and descriptions.

        ordered: bool
            DEPRECATED: Please use `sort=SortComponents.ORDERED_INDICES`.
            If True, then the keys are returned in a deterministic order
            (using the underlying set's `ordered_iter()`).

        """
        ...
    
    def values(self, sort=..., ordered=...): # -> map[ComponentData]:
        """Return an iterator of the component data objects

        Parameters
        ----------
        sort: bool or SortComponents
            Iterate over the declared component values in a specified
            sorted order.  See :py:class:`SortComponents` for valid
            options and descriptions.

        ordered: bool
            DEPRECATED: Please use `sort=SortComponents.ORDERED_INDICES`.
            If True, then the values are returned in a deterministic order
            (using the underlying set's `ordered_iter()`.
        """
        ...
    
    def items(self, sort=..., ordered=...): # -> Generator[tuple[Any | None, ComponentData], None, None]:
        """Return an iterator of (index,data) component data tuples

        Parameters
        ----------
        sort: bool or SortComponents
            Iterate over the declared component items in a specified
            sorted order.  See :py:class:`SortComponents` for valid
            options and descriptions.

        ordered: bool
            DEPRECATED: Please use `sort=SortComponents.ORDERED_INDICES`.
            If True, then the items are returned in a deterministic order
            (using the underlying set's `ordered_iter()`.
        """
        ...
    
    @deprecated('The iterkeys method is deprecated. Use dict.keys().', version='6.0')
    def iterkeys(self): # -> Iterator[Any] | Iterator[None] | filter[None]:
        """Return a list of keys in the dictionary"""
        ...
    
    @deprecated('The itervalues method is deprecated. Use dict.values().', version='6.0')
    def itervalues(self): # -> map[ComponentData]:
        """Return a list of the component data objects in the dictionary"""
        ...
    
    @deprecated('The iteritems method is deprecated. Use dict.items().', version='6.0')
    def iteritems(self): # -> Generator[tuple[Any | None, ComponentData], None, None]:
        """Return a list (index,data) tuples from the dictionary"""
        ...
    
    def __getitem__(self, index) -> ComponentData:
        """
        This method returns the data corresponding to the given index.
        """
        ...
    
    def __setitem__(self, index, val): # -> Self | None:
        ...
    
    def __delitem__(self, index): # -> None:
        ...
    
    def set_value(self, value):
        """Set the value of a scalar component."""
        ...
    
    def id_index_map(self): # -> dict[Any, Any]:
        """
        Return an dictionary id->index for
        all ComponentData instances.
        """
        ...
    


class ActiveIndexedComponent(IndexedComponent, ActiveComponent):
    """
    This is the base class for all indexed modeling components
    whose data members are subclasses of ActiveComponentData, e.g.,
    can be activated or deactivated.

    The activate and deactivate methods activate both the
    component as well as all component data values.
    """
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def activate(self): # -> None:
        """Set the active attribute to True"""
        ...
    
    def deactivate(self): # -> None:
        """Set the active attribute to False"""
        ...
    


class IndexedComponent_NDArrayMixin:
    """Support using IndexedComponent with numpy.ndarray

    This IndexedComponent mixin class adds support for implicitly using
    the IndexedComponent as a term in an expression with numpy ndarray
    objects.

    """
    def __array__(self, dtype=...): # -> Any:
        ...
    
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs): # -> Any:
        ...
    


