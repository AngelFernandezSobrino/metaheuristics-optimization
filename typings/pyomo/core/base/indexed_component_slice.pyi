"""
This type stub file was generated by pyright.
"""

class IndexedComponent_slice:
    """Special class for slicing through hierarchical component trees

    The basic concept is to interrupt the normal slice generation
    procedure to return a specialized iterable class (this object).  This
    object supports simple getitem / getattr / call methods and caches
    them until it is time to actually iterate through the slice.  We
    then walk down the cached names / indices and resolve the final
    objects during the iteration process.  This works because all the
    calls to __getitem__ / __getattr__ / __call__ happen *before* the
    call to __iter__()
    """
    ATTR_MASK = ...
    ITEM_MASK = ...
    CALL_MASK = ...
    GET_MASK = ...
    SET_MASK = ...
    DEL_MASK = ...
    slice_info = ...
    get_attribute = ...
    set_attribute = ...
    del_attribute = ...
    get_item = ...
    set_item = ...
    del_item = ...
    call = ...
    def __init__(self, component, fixed=..., sliced=..., ellipsis=...) -> None:
        """A "slice" over an _IndexedComponent hierarchy

        This class has two forms for the constructor.  The first form is
        the standard constructor that takes a base component and
        indexing information.  This form takes

           IndexedComponent_slice(component, fixed, sliced, ellipsis)

        The second form is a "copy constructor" that is used internally
        when building up the "call stack" for the hierarchical slice.  The
        copy constructor takes an IndexedComponent_slice and an
        optional "next term" in the slice construction (from get/set/del
        item/attr or call):

           IndexedComponent_slice(slice, next_term=None)

        Parameters
        ----------
        component: IndexedComponent
            The base component for this slice

        fixed: dict
            A dictionary indicating the fixed indices of component,
            mapping index position to value

        sliced: dict
            A dictionary indicating the sliced indices of component
            mapping the index position to the (python) slice object

        ellipsis: int
            The position of the ellipsis in the initial component slice

        """
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        """Serialize this object.

        In general, we would not need to implement this (the object does
        not leverage ``__slots__``).  However, because we have a
        "blanket" implementation of :py:meth:`__getattr__`, we need to
        explicitly implement these to avoid "accidentally" extending or
        evaluating this slice."""
        ...
    
    def __setstate__(self, state): # -> None:
        """Deserialize the state into this object."""
        ...
    
    def __deepcopy__(self, memo): # -> Self:
        """Deepcopy this object (leveraging :py:meth:`__getstate__`)"""
        ...
    
    def __iter__(self): # -> _IndexedComponent_slice_iter:
        """Return an iterator over this slice"""
        ...
    
    def __getattr__(self, name): # -> IndexedComponent_slice:
        """Override the "." operator to defer resolution until iteration.

        Creating a slice of a component returns a
        IndexedComponent_slice object.  Subsequent attempts to resolve
        attributes hit this method.
        """
        ...
    
    def __setattr__(self, name, value): # -> None:
        """Override the "." operator implementing attribute assignment

        This supports notation similar to:

            del model.b[:].c.x = 5

        and immediately evaluates the slice.
        """
        ...
    
    def __getitem__(self, idx): # -> IndexedComponent_slice:
        """Override the "[]" operator to defer resolution until iteration.

        Creating a slice of a component returns a
        IndexedComponent_slice object.  Subsequent attempts to query
        items hit this method.
        """
        ...
    
    def __setitem__(self, idx, val): # -> None:
        """Override the "[]" operator for setting item values.

        This supports notation similar to:

            model.b[:].c.x[1,:] = 5

        and immediately evaluates the slice.
        """
        ...
    
    def __delitem__(self, idx): # -> None:
        """Override the "del []" operator for deleting item values.

        This supports notation similar to:

            del model.b[:].c.x[1,:]

        and immediately evaluates the slice.
        """
        ...
    
    def __call__(self, *args, **kwds): # -> IndexedComponent_slice | list[Any | None]:
        """Special handling of the "()" operator for component slices.

        Creating a slice of a component returns a IndexedComponent_slice
        object.  Subsequent attempts to call items hit this method.  We
        handle the __call__ method separately based on the item (identifier
        immediately before the "()") being called:

        - if the item was 'component', then we defer resolution of this call
        until we are actually iterating over the slice.  This allows users
        to do operations like `m.b[:].component('foo').bar[:]`

        - if the item is anything else, then we will immediately iterate over
        the slice and call the item.  This allows "vector-like" operations
        like: `m.x[:,1].fix(0)`.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def duplicate(self): # -> IndexedComponent_slice:
        ...
    
    def index_wildcard_keys(self, sort): # -> Generator[Any | tuple[Any, ...] | None, None, None]:
        ...
    
    def wildcard_keys(self, sort=...): # -> Generator[Any | tuple[Any, ...] | None, None, None]:
        ...
    
    def wildcard_values(self, sort=...): # -> _IndexedComponent_slice_iter:
        """Return an iterator over this slice"""
        ...
    
    def wildcard_items(self, sort=...): # -> Generator[tuple[Any | tuple[Any, ...] | None, Any | None], None, None]:
        ...
    
    def expanded_keys(self): # -> Generator[Any | tuple[()], None, None]:
        ...
    
    def expanded_items(self): # -> Generator[tuple[Any | tuple[()], Any | None], None, None]:
        ...
    


class _slice_generator:
    """Utility (iterator) for generating the elements of one slice

    Iterate through the component index and yield the component data
    values that match the slice template.
    """
    def __init__(self, component, fixed, sliced, ellipsis, iter_over_index, sort) -> None:
        ...
    
    def next(self): # -> Any | None:
        """__next__() iterator for Py2 compatibility"""
        ...
    
    def __next__(self): # -> Any | None:
        ...
    


_IndexedComponent_slice = IndexedComponent_slice
class _NotIterable:
    ...


class _IndexedComponent_slice_iter:
    def __init__(self, component_slice, advance_iter=..., iter_over_index=..., sort=...) -> None:
        ...
    
    def __iter__(self): # -> Self:
        """This class implements the iterator API"""
        ...
    
    def next(self): # -> Any | None:
        """__next__() iterator for Py2 compatibility"""
        ...
    
    def __next__(self): # -> Any | None:
        """Return the next element in the slice."""
        ...
    
    def get_last_index(self): # -> tuple[()]:
        ...
    
    def get_last_index_wildcards(self): # -> tuple[Any, ...] | None:
        """Get a tuple of the values in the wildcard positions for the most
        recent indices corresponding to the last component returned by
        each _slice_generator in the iter stack.

        """
        ...
    


