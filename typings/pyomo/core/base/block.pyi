"""
This type stub file was generated by pyright.
"""

from typing import Any, Type, Union
from pyomo.common.autoslots import AutoSlots
from pyomo.common.deprecation import RenamedClass, deprecated
from pyomo.common.pyomo_typing import overload
from pyomo.core.base.component import ActiveComponentData, Component, ModelComponentFactory
from pyomo.core.base.set import Any
from pyomo.core.base.indexed_component import ActiveIndexedComponent, IndexedComponent

logger = ...
class _generic_component_decorator:
    """A generic decorator that wraps Block.__setattr__()

    Arguments
    ---------
        component: the Pyomo Component class to construct
        block: the block onto which to add the new component
        *args: positional arguments to the Component constructor
               (*excluding* the block argument)
        **kwds: keyword arguments to the Component constructor
    """
    def __init__(self, component, block, *args, **kwds) -> None:
        ...
    
    def __call__(self, rule):
        ...
    


class _component_decorator:
    """A class that wraps the _generic_component_decorator, which remembers
    and provides the Block and component type to the decorator.

    Arguments
    ---------
        component: the Pyomo Component class to construct
        block: the block onto which to add the new component

    """
    def __init__(self, block, component) -> None:
        ...
    
    def __call__(self, *args, **kwds): # -> _generic_component_decorator:
        ...
    


class SubclassOf:
    """This mocks up a tuple-like interface based on subclass relationship.

    Instances of this class present a somewhat tuple-like interface for
    use in PseudoMap ctype / descend_into.  The constructor takes a
    single ctype argument.  When used with PseudoMap (through Block APIs
    like component_objects()), it will match any ctype that is a
    subclass of the reference ctype.

    This allows, for example:

        model.component_data_objects(Var, descend_into=SubclassOf(Block))
    """
    def __init__(self, *ctype) -> None:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __len__(self): # -> Literal[1]:
        ...
    
    def __getitem__(self, item): # -> Self:
        ...
    
    def __iter__(self): # -> Iterator[Self]:
        ...
    


class _DeduplicateInfo:
    """Class implementing a unique component data object filter

    This class implements :py:meth:`unique()`, which is an efficient
    Reference-aware filter that wraps a generator and returns only
    unique component data objects.  This is nominally the same as:

        seen = set()
        for data in iterator:
            if id(data) not in seen:
                seen.add(id(data))
                yield data

    However, it is aware of the existence of Reference components (and
    that the only way you should ever encounter a duplicate is through a
    Reference).  This allows it to avoid generating and storing the id()
    of every data object.

    """
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def unique(self, comp, items, are_values): # -> filterfalse[Any]:
        """Returns generator that filters duplicate ComponentData objects from items

        Parameters
        ----------
        comp: ComponentBase
           The Component (indexed or scalar) that contains all
           ComponentData returned by the `items` generator.  `comp` may
           be an IndexedComponent generated by :py:func:`Reference` (and
           hence may not own the component datas in `items`)

        items: generator
            Generator yielding either the values or the items from the
            `comp` Component.

        are_values: bool
            If `True`, `items` yields ComponentData objects, otherwise,
            `items` yields `(index, ComponentData)` tuples.

        """
        ...
    


class _BlockConstruction:
    """
    This class holds a "global" dict used when constructing
    (hierarchical) models.
    """
    data = ...


class PseudoMap(AutoSlots.Mixin):
    """
    This class presents a "mock" dict interface to the internal
    BlockData data structures.  We return this object to the
    user to preserve the historical "{ctype : {name : obj}}"
    interface without actually regenerating that dict-of-dicts data
    structure.

    We now support {ctype : PseudoMap()}
    """
    __slots__ = ...
    def __init__(self, block, ctype, active=..., sort=...) -> None:
        """
        TODO
        """
        ...
    
    def __iter__(self): # -> map[Any]:
        """
        TODO
        """
        ...
    
    def __getitem__(self, key):
        """
        TODO
        """
        ...
    
    def __nonzero__(self): # -> bool:
        """
        TODO
        """
        ...
    
    __bool__ = ...
    def __len__(self): # -> int:
        """
        TODO
        """
        ...
    
    def __contains__(self, key): # -> bool:
        """
        TODO
        """
        ...
    
    def keys(self): # -> map[Any]:
        """
        Generator returning the component names defined on the Block
        """
        ...
    
    def values(self): # -> Iterator[Any] | filter[Any] | filterfalse[Any] | Generator[Any, Any, None]:
        """
        Generator returning the components defined on the Block
        """
        ...
    
    def items(self): # -> Generator[tuple[Any, Any], Any, None]:
        """
        Generator returning (name, component) tuples for components
        defined on the Block
        """
        ...
    
    @deprecated('The iterkeys method is deprecated. Use dict.keys().', version='6.0')
    def iterkeys(self): # -> map[Any]:
        """
        Generator returning the component names defined on the Block
        """
        ...
    
    @deprecated('The itervalues method is deprecated. Use dict.values().', version='6.0')
    def itervalues(self): # -> Iterator[Any] | filter[Any] | filterfalse[Any] | Generator[Any, Any, None]:
        """
        Generator returning the components defined on the Block
        """
        ...
    
    @deprecated('The iteritems method is deprecated. Use dict.items().', version='6.0')
    def iteritems(self): # -> Generator[tuple[Any, Any], Any, None]:
        """
        Generator returning (name, component) tuples for components
        defined on the Block
        """
        ...
    


class BlockData(ActiveComponentData):
    """
    This class holds the fundamental block data.
    """
    _Block_reserved_words = ...
    __autoslot_mappers = ...
    def __init__(self, component) -> None:
        ...
    
    def __getattr__(self, val) -> Union[Component, IndexedComponent, Any]:
        ...
    
    def __setattr__(self, name: str, val: Union[Component, IndexedComponent, Any]): # -> None:
        """
        Set an attribute of a block data object.
        """
        ...
    
    def __delattr__(self, name): # -> None:
        """
        Delete an attribute on this Block.
        """
        ...
    
    def set_value(self, val):
        ...
    
    def clear(self): # -> None:
        ...
    
    def transfer_attributes_from(self, src): # -> None:
        """Transfer user-defined attributes from src to this block

        This transfers all components and user-defined attributes from
        the block or dictionary `src` and places them on this Block.
        Components are transferred in declaration order.

        If a Component on `src` is also declared on this block as either
        a Component or attribute, the local Component or attribute is
        replaced by the incoming component.  If an attribute name on
        `src` matches a Component declared on this block, then the
        incoming attribute is passed to the local Component's
        `set_value()` method.  Attribute names appearing in this block's
        `_Block_reserved_words` set will not be transferred (although
        Components will be).

        Parameters
        ----------
        src: BlockData or dict
            The Block or mapping that contains the new attributes to
            assign to this block.
        """
        ...
    
    def collect_ctypes(self, active=..., descend_into=...): # -> set[Any]:
        """
        Count all component types stored on or under this
        block.

        Args:
            active (True/None): Set to True to indicate that
                only active components should be
                counted. The default value of None indicates
                that all components (including those that
                have been deactivated) should be counted.
            descend_into (bool): Indicates whether or not
                component types should be counted on
                sub-blocks. Default is True.

        Returns: A set of component types.
        """
        ...
    
    def model(self): # -> Self:
        ...
    
    def find_component(self, label_or_component): # -> Any | None:
        """
        Returns a component in the block given a name.

        Parameters
        ----------
        label_or_component : str, Component, or ComponentUID
            The name of the component to find in this block. String or
            Component arguments are first converted to ComponentUID.

        Returns
        -------
        Component
            Component on the block identified by the ComponentUID. If
            a matching component is not found, None is returned.

        """
        ...
    
    def add_component(self, name, val): # -> None:
        """
        Add a component 'name' to the block.

        This method assumes that the attribute is not in the model.
        """
        ...
    
    def del_component(self, name_or_object): # -> None:
        """
        Delete a component from this block.
        """
        ...
    
    def reclassify_component_type(self, name_or_object, new_ctype, preserve_declaration_order=...): # -> None:
        """
        TODO
        """
        ...
    
    def clone(self, memo=...): # -> Self:
        """
        TODO
        """
        ...
    
    def contains_component(self, ctype): # -> Any | Literal[False]:
        """
        Return True if the component type is in _ctypes and ... TODO.
        """
        ...
    
    def component(self, name_or_object): # -> None:
        """
        Return a child component of this block.

        If passed a string, this will return the child component
        registered by that name.  If passed a component, this will
        return that component IFF the component is a child of this
        block. Returns None on lookup failure.
        """
        ...
    
    def component_map(self, ctype=..., active=..., sort=...): # -> PseudoMap:
        """Returns a PseudoMap of the components in this block.

        Parameters
        ----------
        ctype:  None or type or iterable
            Specifies the component types (`ctypes`) to include in the
            resulting PseudoMap

                =============   ===================================
                None            All components
                type            A single component type
                iterable        All component types in the iterable
                =============   ===================================

        active: None or bool
            Filter components by the active flag

                =====  ===============================
                None   Return all components
                True   Return only active components
                False  Return only inactive components
                =====  ===============================

        sort: bool
            Iterate over the components in a sorted order

                =====  ================================================
                True   Iterate using Block.alphabetizeComponentAndIndex
                False  Iterate using Block.declarationOrder
                =====  ================================================

        """
        ...
    
    @deprecated("The all_components method is deprecated.  " "Use the Block.component_objects() method.", version="4.1.10486")
    def all_components(self, *args, **kwargs): # -> Generator[Any, Any, None]:
        ...
    
    @deprecated("The active_components method is deprecated.  " "Use the Block.component_objects() method.", version="4.1.10486")
    def active_components(self, *args, **kwargs): # -> Generator[Any, Any, None]:
        ...
    
    @deprecated("The all_component_data method is deprecated.  " "Use the Block.component_data_objects() method.", version="4.1.10486")
    def all_component_data(self, *args, **kwargs): # -> Generator[Any, Any, None]:
        ...
    
    @deprecated("The active_component_data method is deprecated.  " "Use the Block.component_data_objects() method.", version="4.1.10486")
    def active_component_data(self, *args, **kwargs): # -> Generator[Any, Any, None]:
        ...
    
    def component_objects(self, ctype=..., active=..., sort=..., descend_into=..., descent_order=...): # -> Generator[Any, Any, None]:
        """
        Return a generator that iterates through the
        component objects in a block.  By default, the
        generator recursively descends into sub-blocks.
        """
        ...
    
    def component_data_objects(self, ctype=..., active=..., sort=..., descend_into=..., descent_order=...): # -> Generator[Any, Any, None]:
        """
        Return a generator that iterates through the
        component data objects for all components in a
        block.  By default, this generator recursively
        descends into sub-blocks.
        """
        ...
    
    @deprecated("The component_data_iterindex method is deprecated.  " "Components now know their index, so it is more efficient to use the " "Block.component_data_objects() method followed by .index().", version="6.6.0")
    def component_data_iterindex(self, ctype=..., active=..., sort=..., descend_into=..., descent_order=...): # -> Generator[Any, Any, None]:
        """
        Return a generator that returns a tuple for each
        component data object in a block.  By default, this
        generator recursively descends into sub-blocks.  The
        tuple is

            ((component name, index value), ComponentData)

        """
        ...
    
    @deprecated("The all_blocks method is deprecated.  " "Use the Block.block_data_objects() method.", version="4.1.10486")
    def all_blocks(self, *args, **kwargs): # -> tuple[()] | tuple[Self] | Generator[Self, Any, None] | Generator[Self | Any, Any, None]:
        ...
    
    @deprecated("The active_blocks method is deprecated.  " "Use the Block.block_data_objects() method.", version="4.1.10486")
    def active_blocks(self, *args, **kwargs): # -> tuple[()] | tuple[Self] | Generator[Self, Any, None] | Generator[Self | Any, Any, None]:
        ...
    
    def block_data_objects(self, active=..., sort=..., descend_into=..., descent_order=...): # -> tuple[()] | tuple[Self] | Generator[Self, Any, None] | Generator[Self | Any, Any, None]:
        """Returns this block and any matching sub-blocks.

        This is roughly equivalent to

        .. code-block:: python

            iter(block for block in itertools.chain(
                 [self], self.component_data_objects(descend_into, ...))
                 if block.active == active)

        Notes
        -----
        The `self` block is *always* returned, regardless of the types
        indicated by `descend_into`.

        The active flag is enforced on *all* blocks, including `self`.

        Parameters
        ----------
        active: None or bool
            If not None, filter components by the active flag

        sort: None or bool or SortComponents
            Iterate over the components in a specified sorted order

        descend_into:  None or type or iterable
            Specifies the component types (`ctypes`) to return and to
            descend into.  If `True` or `None`, defaults to `(Block,)`.
            If `False`, only `self` is returned.

        descent_order: None or TraversalStrategy
            The strategy used to walk the block hierarchy.  Defaults to
            `TraversalStrategy.PrefixDepthFirstSearch`.

        Returns
        -------
        tuple or generator

        """
        ...
    
    def fix_all_vars(self): # -> None:
        ...
    
    def unfix_all_vars(self): # -> None:
        ...
    
    def is_constructed(self): # -> bool:
        """
        A boolean indicating whether or not all *active* components of the
        input model have been properly constructed.
        """
        ...
    
    def display(self, filename=..., ostream=..., prefix=...): # -> None:
        """
        Print the Pyomo model in a verbose format.
        """
        ...
    
    def valid_problem_types(self): # -> list[ProblemFormat]:
        """This method allows the pyomo.opt convert function to work with a
        Model object."""
        ...
    
    def write(self, filename=..., format=..., solver_capability=..., io_options=..., int_marker=...): # -> tuple[Any, int]:
        """
        Write the model to a file, with a given format.
        """
        ...
    
    def private_data(self, scope=...):
        ...
    


class _BlockData(metaclass=RenamedClass):
    __renamed__new_class__ = BlockData
    __renamed__version__ = ...


@ModelComponentFactory.register("A component that contains one or more model components.")
class Block(ActiveIndexedComponent):
    """
    Blocks are indexed components that contain other components
    (including blocks).  Blocks have a global attribute that defines
    whether construction is deferred.  This applies to all components
    that they contain except blocks.  Blocks contained by other
    blocks use their local attribute to determine whether construction
    is deferred.
    """
    _ComponentDataClass = BlockData
    _private_data_initializers = ...
    @overload
    def __new__(cls: Type[Block], *args, **kwds) -> Union[ScalarBlock, IndexedBlock]:
        ...
    
    @overload
    def __new__(cls: Type[ScalarBlock], *args, **kwds) -> ScalarBlock:
        ...
    
    @overload
    def __new__(cls: Type[IndexedBlock], *args, **kwds) -> IndexedBlock:
        ...
    
    def __new__(cls, *args, **kwds): # -> Self:
        ...
    
    @overload
    def __init__(self, *indexes, rule=..., concrete=..., dense=..., name=..., doc=...) -> None:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        """Constructor"""
        ...
    
    def construct(self, data=...): # -> None:
        """
        Initialize the block
        """
        ...
    
    def display(self, filename=..., ostream=..., prefix=...): # -> None:
        """
        Display values in the block
        """
        ...
    
    @staticmethod
    def register_private_data_initializer(initializer, scope=...): # -> None:
        ...
    


class ScalarBlock(BlockData, Block):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    display = ...


class SimpleBlock(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarBlock
    __renamed__version__ = ...


class IndexedBlock(Block):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    @overload
    def __getitem__(self, index) -> BlockData:
        ...
    
    __getitem__ = ...


@deprecated("generate_cuid_names() is deprecated. " "Use the ComponentUID.generate_cuid_string_map() static method", version="5.7.2")
def generate_cuid_names(block, ctype=..., descend_into=...): # -> ComponentMap:
    ...

@deprecated("The active_components function is deprecated.  " "Use the Block.component_objects() method.", version="4.1.10486")
def active_components(block, ctype, sort_by_names=..., sort_by_keys=...):
    ...

@deprecated("The components function is deprecated.  " "Use the Block.component_objects() method.", version="4.1.10486")
def components(block, ctype, sort_by_names=..., sort_by_keys=...):
    ...

@deprecated("The active_components_data function is deprecated.  " "Use the Block.component_data_objects() method.", version="4.1.10486")
def active_components_data(block, ctype, sort=..., sort_by_keys=..., sort_by_names=...):
    ...

@deprecated("The components_data function is deprecated.  " "Use the Block.component_data_objects() method.", version="4.1.10486")
def components_data(block, ctype, sort=..., sort_by_keys=..., sort_by_names=...):
    ...

class ScalarCustomBlockMixin:
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class CustomBlock(Block):
    """The base class used by instances of custom block components"""
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __new__(cls, *args, **kwargs): # -> Self:
        ...
    


def declare_custom_block(name, new_ctype=...): # -> Callable[..., Any]:
    """Decorator to declare components for a custom block data class

    >>> @declare_custom_block(name="FooBlock")
    ... class FooBlockData(BlockData):
    ...    # custom block data class
    ...    pass
    """
    ...

