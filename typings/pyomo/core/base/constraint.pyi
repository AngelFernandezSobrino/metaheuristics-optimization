"""
This type stub file was generated by pyright.
"""

from pyomo.common.pyomo_typing import overload
from typing import Type, Union
from pyomo.common.deprecation import RenamedClass
from pyomo.core.base.component import ActiveComponentData, ModelComponentFactory
from pyomo.core.base.indexed_component import ActiveIndexedComponent
from pyomo.core.base.disable_methods import disable_methods

logger = ...
TEMPLATIZE_CONSTRAINTS = ...
_inf = ...
_nonfinite_values = ...
_known_relational_expressions = ...
_strict_relational_exprs = ...
_rule_returned_none_error = ...
def simple_constraint_rule(rule): # -> PyomoObject | Any:
    """
    This is a decorator that translates None/True/False return
    values into Constraint.Skip/Constraint.Feasible/Constraint.Infeasible.
    This supports a simpler syntax in constraint rules, though these
    can be more difficult to debug when errors occur.

    Example use:

    .. code::

        @simple_constraint_rule
        def C_rule(model, i, j):
            # ...

        model.c = Constraint(rule=simple_constraint_rule(...))

    """
    ...

def simple_constraintlist_rule(rule): # -> PyomoObject | Any:
    """
    This is a decorator that translates None/True/False return values
    into ConstraintList.End/Constraint.Feasible/Constraint.Infeasible.
    This supports a simpler syntax in constraint rules, though these can be
    more difficult to debug when errors occur.

    Example use:

    .. code::

        @simple_constraintlist_rule
        def C_rule(model, i, j):
             # ...

        model.c = ConstraintList(expr=simple_constraintlist_rule(...))

    """
    ...

class ConstraintData(ActiveComponentData):
    """This class defines the data for a single algebraic constraint.

    Parameters
    ----------
    expr : ExpressionBase
        The Pyomo expression stored in this constraint.

    component : Constraint
        The Constraint object that owns this data.

    """
    __slots__ = ...
    _linear_canonical_form = ...
    def __init__(self, expr=..., component=...) -> None:
        ...
    
    def __call__(self, exception=...): # -> None:
        """Compute the value of the body of this constraint."""
        ...
    
    def to_bounded_expression(self, evaluate_bounds=...): # -> tuple[float | Any | None, Any | None, float | Any | None] | tuple[None, None, None] | tuple[Any | None, Any, Any] | tuple[Any, Any, Any | None] | tuple[Literal[0] | None, Any, Literal[0]]:
        """Convert this constraint to a tuple of 3 expressions (lb, body, ub)

        This method "standardizes" the expression into a 3-tuple of
        expressions: (`lower_bound`, `body`, `upper_bound`).  Upon
        conversion, `lower_bound` and `upper_bound` are guaranteed to be
        `None`, numeric constants, or fixed (not necessarily constant)
        expressions.

        Note
        ----
        As this method operates on the *current state* of the
        expression, any required expression manipulations (and by
        extension, the result) can change after fixing / unfixing
        :py:class:`Var` objects.

        Parameters
        ----------
        evaluate_bounds: bool

            If True, then the lower and upper bounds will be evaluated
            to a finite numeric constant or None.

        Raises
        ------

        ValueError: Raised if the expression cannot be mapped to this
            form (i.e., :py:class:`RangedExpression` constraints with
            variable lower or upper bounds.

        """
        ...
    
    @property
    def body(self): # -> NumericConstant | None:
        """The body (variable portion) of a constraint expression."""
        ...
    
    @property
    def lower(self): # -> NumericConstant | float | Literal[0] | None:
        """The lower bound of a constraint expression.

        This is the fixed lower bound of a Constraint as a Pyomo
        expression.  This may contain potentially variable terms
        that are currently fixed.  If there is no lower bound, this will
        return `None`.

        """
        ...
    
    @property
    def upper(self): # -> NumericConstant | float | Literal[0] | None:
        """Access the upper bound of a constraint expression.

        This is the fixed upper bound of a Constraint as a Pyomo
        expression.  This may contain potentially variable terms
        that are currently fixed.  If there is no upper bound, this will
        return `None`.

        """
        ...
    
    @property
    def lb(self): # -> float | None:
        """float : the value of the lower bound of a constraint expression."""
        ...
    
    @property
    def ub(self): # -> float | None:
        """float : the value of the upper bound of a constraint expression."""
        ...
    
    @property
    def equality(self): # -> bool:
        """bool : True if this is an equality constraint."""
        ...
    
    @property
    def strict_lower(self): # -> Literal[False]:
        """bool : True if this constraint has a strict lower bound."""
        ...
    
    @property
    def strict_upper(self): # -> Literal[False]:
        """bool : True if this constraint has a strict upper bound."""
        ...
    
    def has_lb(self): # -> bool:
        """Returns :const:`False` when the lower bound is
        :const:`None` or negative infinity"""
        ...
    
    def has_ub(self): # -> bool:
        """Returns :const:`False` when the upper bound is
        :const:`None` or positive infinity"""
        ...
    
    @property
    def expr(self): # -> EqualityExpression | InequalityExpression | RangedExpression | None:
        """Return the expression associated with this constraint."""
        ...
    
    def get_value(self): # -> EqualityExpression | InequalityExpression | RangedExpression | None:
        """Get the expression on this constraint."""
        ...
    
    def set_value(self, expr): # -> None:
        """Set the expression on this constraint."""
        ...
    
    def lslack(self): # -> float:
        """
        Returns the value of f(x)-L for constraints of the form:
            L <= f(x) (<= U)
            (U >=) f(x) >= L
        """
        ...
    
    def uslack(self): # -> float:
        """
        Returns the value of U-f(x) for constraints of the form:
            (L <=) f(x) <= U
            U >= f(x) (>= L)
        """
        ...
    
    def slack(self):
        """
        Returns the smaller of lslack and uslack values
        """
        ...
    


class _ConstraintData(metaclass=RenamedClass):
    __renamed__new_class__ = ConstraintData
    __renamed__version__ = ...


class _GeneralConstraintData(metaclass=RenamedClass):
    __renamed__new_class__ = ConstraintData
    __renamed__version__ = ...


class TemplateConstraintData(ConstraintData):
    __slots__ = ...
    def __init__(self, template_info, component, index) -> None:
        ...
    
    @property
    def expr(self):
        ...
    
    def template_expr(self): # -> Any:
        ...
    
    def set_value(self, expr):
        ...
    
    def to_bounded_expression(self): # -> tuple[float | Any | None, Any | None, float | Any | None] | tuple[None, None, None] | tuple[Any | None, Any, Any] | tuple[Any, Any, Any | None] | tuple[Literal[0] | None, Any, Literal[0]]:
        ...
    


@ModelComponentFactory.register("General constraint expressions.")
class Constraint(ActiveIndexedComponent):
    """
    This modeling component defines a constraint expression using a
    rule function.

    Constructor arguments:
        expr
            A Pyomo expression for this constraint
        rule
            A function that is used to construct constraint expressions
        name
            A name for this component
        doc
            A text string describing this component

    Public class attributes:
        doc
            A text string describing this component
        name
            A name for this component
        active
            A boolean that is true if this component will be used to
            construct a model instance
        rule
           The rule used to initialize the constraint(s)

    Private class attributes:
        _constructed
            A boolean that is true if this component has been constructed
        _data
            A dictionary from the index set to component data objects
        _index
            The set of valid indices
        _model
            A weakref to the model that owns this component
        _parent
            A weakref to the parent block that owns this component
        _type
            The class type for the derived subclass
    """
    _ComponentDataClass = ConstraintData
    class Infeasible:
        ...
    
    
    Feasible = ActiveIndexedComponent.Skip
    NoConstraint = ActiveIndexedComponent.Skip
    Violated = Infeasible
    Satisfied = Feasible
    @overload
    def __new__(cls: Type[Constraint], *args, **kwds) -> Union[ScalarConstraint, IndexedConstraint]:
        ...
    
    @overload
    def __new__(cls: Type[ScalarConstraint], *args, **kwds) -> ScalarConstraint:
        ...
    
    @overload
    def __new__(cls: Type[IndexedConstraint], *args, **kwds) -> IndexedConstraint:
        ...
    
    def __new__(cls, *args, **kwds): # -> Self:
        ...
    
    @overload
    def __init__(self, *indexes, expr=..., rule=..., name=..., doc=...) -> None:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def construct(self, data=...):
        """
        Construct the expression(s) for this constraint.
        """
        ...
    
    def display(self, prefix=..., ostream=...): # -> None:
        """
        Print component state information

        This duplicates logic in Component.pprint()
        """
        ...
    


class ScalarConstraint(ConstraintData, Constraint):
    """
    ScalarConstraint is the implementation representing a single,
    non-indexed constraint.
    """
    def __init__(self, *args, **kwds) -> None:
        ...
    
    @property
    def body(self): # -> Any:
        """The body (variable portion) of a constraint expression."""
        ...
    
    @property
    def lower(self): # -> Any:
        """The lower bound of a constraint expression.

        This is the fixed lower bound of a Constraint as a Pyomo
        expression.  This may contain potentially variable terms
        that are currently fixed.  If there is no lower bound, this will
        return `None`.

        """
        ...
    
    @property
    def upper(self): # -> Any:
        """Access the upper bound of a constraint expression.

        This is the fixed upper bound of a Constraint as a Pyomo
        expression.  This may contain potentially variable terms
        that are currently fixed.  If there is no upper bound, this will
        return `None`.

        """
        ...
    
    @property
    def equality(self): # -> Any:
        """bool : True if this is an equality constraint."""
        ...
    
    @property
    def strict_lower(self): # -> Any:
        """bool : True if this constraint has a strict lower bound."""
        ...
    
    @property
    def strict_upper(self): # -> Any:
        """bool : True if this constraint has a strict upper bound."""
        ...
    
    def clear(self): # -> None:
        ...
    
    def set_value(self, expr): # -> None:
        """Set the expression on this constraint."""
        ...
    
    def add(self, index, expr): # -> Self:
        """Add a constraint with a given index."""
        ...
    


class SimpleConstraint(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarConstraint
    __renamed__version__ = ...


@disable_methods('add', 'set_value', 'to_bounded_expression', 'body', 'lower', 'upper', 'equality', 'strict_lower', 'strict_upper')
class AbstractScalarConstraint(ScalarConstraint):
    ...


class AbstractSimpleConstraint(metaclass=RenamedClass):
    __renamed__new_class__ = AbstractScalarConstraint
    __renamed__version__ = ...


class IndexedConstraint(Constraint):
    def add(self, index, expr): # -> Self | None:
        """Add a constraint with a given index."""
        ...
    
    @overload
    def __getitem__(self, index) -> ConstraintData:
        ...
    
    __getitem__ = ...


@ModelComponentFactory.register("A list of constraint expressions.")
class ConstraintList(IndexedConstraint):
    """
    A constraint component that represents a list of constraints.
    Constraints can be indexed by their index, but when they are
    added an index value is not specified.
    """
    class End:
        ...
    
    
    def __init__(self, **kwargs) -> None:
        """Constructor"""
        ...
    
    def construct(self, data=...): # -> None:
        """
        Construct the expression(s) for this constraint.
        """
        ...
    
    def add(self, expr): # -> Self | None:
        """Add a constraint with an implicit index."""
        ...
    


