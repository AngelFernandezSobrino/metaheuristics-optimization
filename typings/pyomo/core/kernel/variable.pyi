"""
This type stub file was generated by pyright.
"""

from pyomo.core.expr.numvalue import NumericValue, value
from pyomo.core.kernel.base import ICategorizedObject

_pos_inf = ...
_neg_inf = ...
class IVariable(ICategorizedObject, NumericValue):
    """The interface for decision variables"""
    __slots__ = ...
    _valid_domain_types = ...
    domain_type = ...
    lb = ...
    ub = ...
    value = ...
    fixed = ...
    stale = ...
    @property
    def bounds(self): # -> tuple[Any | None, Any | None]:
        """Get/Set the bounds as a tuple (lb, ub)."""
        ...
    
    @bounds.setter
    def bounds(self, bounds_tuple): # -> None:
        ...
    
    @property
    def lb(self): # -> None:
        """Return the numeric value of the variable lower bound."""
        ...
    
    @lb.setter
    def lb(self, val): # -> None:
        ...
    
    @property
    def ub(self): # -> None:
        """Return the numeric value of the variable upper bound."""
        ...
    
    @ub.setter
    def ub(self, val): # -> None:
        ...
    
    def fix(self, value=...): # -> None:
        """
        Fix the variable. Sets the fixed indicator to
        :const:`True`. An optional value argument will
        update the variable's value before fixing.
        """
        ...
    
    def unfix(self): # -> None:
        """Free the variable. Sets the fixed indicator to
        :const:`False`."""
        ...
    
    free = ...
    def has_lb(self): # -> Literal[False]:
        """Returns :const:`False` when the lower bound is
        :const:`None` or negative infinity"""
        ...
    
    def has_ub(self): # -> Literal[False]:
        """Returns :const:`False` when the upper bound is
        :const:`None` or positive infinity"""
        ...
    
    @property
    def lslack(self): # -> Any | None:
        """Lower slack (value - lb). Returns :const:`None` if
        the variable value is :const:`None`."""
        ...
    
    @property
    def uslack(self): # -> Any | None:
        """Upper slack (ub - value). Returns :const:`None` if
        the variable value is :const:`None`."""
        ...
    
    @property
    def slack(self): # -> None:
        """min(lslack, uslack). Returns :const:`None` if
        the variable value is :const:`None`."""
        ...
    
    def is_continuous(self): # -> Any:
        """Returns :const:`True` when the domain type is
        :class:`RealSet`."""
        ...
    
    def is_discrete(self): # -> bool:
        """Returns :const:`True` when the domain type is
        :class:`IntegerSet`."""
        ...
    
    def is_integer(self): # -> Any:
        """Returns :const:`True` when the domain type is
        :class:`IntegerSet`."""
        ...
    
    def is_binary(self): # -> Any | bool:
        """Returns :const:`True` when the domain type is
        :class:`IntegerSet` and the bounds are within
        [0,1]."""
        ...
    
    def is_fixed(self): # -> Any | bool:
        """Returns :const:`True` if this variable is fixed,
        otherwise returns :const:`False`."""
        ...
    
    def is_constant(self): # -> Literal[False]:
        """Returns :const:`False` because this is not a
        constant in an expression."""
        ...
    
    def is_parameter_type(self): # -> Literal[False]:
        """Returns :const:`False` because this is not a
        parameter object."""
        ...
    
    def is_variable_type(self): # -> Literal[True]:
        """Returns :const:`True` because this is a
        variable object."""
        ...
    
    def is_potentially_variable(self): # -> Literal[True]:
        """Returns :const:`True` because this is a
        variable."""
        ...
    
    def polynomial_degree(self): # -> Literal[0, 1]:
        """Return the polynomial degree of this
        expression"""
        ...
    
    def __call__(self, exception=...): # -> Any | NoArgumentGiven:
        """Return the value of this variable."""
        ...
    


class variable(IVariable):
    """A decision variable

    Decision variables are used in objectives and
    constraints to define an optimization problem.

    Args:
        domain_type: Sets the domain type of the
            variable. Must be one of :const:`RealSet` or
            :const:`IntegerSet`. Can be updated later by
            assigning to the :attr:`domain_type`
            property. The default value of :const:`None` is
            equivalent to :const:`RealSet`, unless the
            :attr:`domain` keyword is used.
        domain: Sets the domain of the variable. This
            updates the :attr:`domain_type`, :attr:`lb`, and
            :attr:`ub` properties of the variable. The
            default value of :const:`None` implies that this
            keyword is ignored. This keyword can not be used
            in combination with the :attr:`domain_type`
            keyword.
        lb: Sets the lower bound of the variable. Can be
            updated later by assigning to the :attr:`lb`
            property on the variable. Default is
            :const:`None`, which is equivalent to
            :const:`-inf`.
        ub: Sets the upper bound of the variable. Can be
            updated later by assigning to the :attr:`ub`
            property on the variable. Default is
            :const:`None`, which is equivalent to
            :const:`+inf`.
        value: Sets the value of the variable. Can be
            updated later by assigning to the :attr:`value`
            property on the variable. Default is
            :const:`None`.
        fixed (bool): Sets the fixed status of the
            variable. Can be updated later by assigning to
            the :attr:`fixed` property or by calling the
            :meth:`fix` method. Default is :const:`False`.

    Examples:
        >>> import pyomo.kernel as pmo
        >>> # A continuous variable with infinite bounds
        >>> x = pmo.variable()
        >>> # A binary variable
        >>> x = pmo.variable(domain=pmo.Binary)
        >>> # Also a binary variable
        >>> x = pmo.variable(domain_type=pmo.IntegerSet, lb=0, ub=1)
    """
    _ctype = IVariable
    __slots__ = ...
    def __init__(self, domain_type=..., domain=..., lb=..., ub=..., value=..., fixed=...) -> None:
        ...
    
    @property
    def lower(self): # -> None:
        """The lower bound of the variable"""
        ...
    
    @lower.setter
    def lower(self, lb): # -> None:
        ...
    
    @property
    def upper(self): # -> None:
        """The upper bound of the variable"""
        ...
    
    @upper.setter
    def upper(self, ub): # -> None:
        ...
    
    @property
    def value(self): # -> None:
        """The value of the variable"""
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def set_value(self, value, skip_validation=...): # -> None:
        ...
    
    @property
    def fixed(self): # -> bool:
        """The fixed status of the variable"""
        ...
    
    @fixed.setter
    def fixed(self, fixed): # -> None:
        ...
    
    @property
    def stale(self): # -> bool:
        """The stale status of the variable"""
        ...
    
    @stale.setter
    def stale(self, stale): # -> None:
        ...
    
    @property
    def domain_type(self): # -> type[RealSet] | type[IntegerSet]:
        """The domain type of the variable (:class:`RealSet`
        or :class:`IntegerSet`)"""
        ...
    
    @domain_type.setter
    def domain_type(self, domain_type): # -> None:
        ...
    
    domain = ...


