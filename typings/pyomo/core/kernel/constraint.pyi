"""
This type stub file was generated by pyright.
"""

from pyomo.core.kernel.base import ICategorizedObject

_pos_inf = ...
_neg_inf = ...
_RELATIONAL = ...
class IConstraint(ICategorizedObject):
    """The interface for constraints"""
    __slots__ = ...
    body = ...
    lower = ...
    upper = ...
    lb = ...
    ub = ...
    rhs = ...
    equality = ...
    _linear_canonical_form = ...
    def __call__(self, exception=...): # -> Any | None:
        """Compute the value of the body of this constraint."""
        ...
    
    @property
    def lslack(self): # -> Any | None:
        """Lower slack (body - lb). Returns :const:`None` if
        a value for the body can not be computed."""
        ...
    
    @property
    def uslack(self): # -> Any | None:
        """Upper slack (ub - body). Returns :const:`None` if
        a value for the body can not be computed."""
        ...
    
    @property
    def slack(self): # -> None:
        """min(lslack, uslack). Returns :const:`None` if a
        value for the body can not be computed."""
        ...
    
    @property
    def expr(self): # -> Any | RangedExpression | None:
        """Get the expression on this constraint."""
        ...
    
    @property
    def bounds(self): # -> tuple[Any, Any]:
        """The bounds of the constraint as a tuple (lb, ub)"""
        ...
    
    def has_lb(self): # -> Literal[False]:
        """Returns :const:`False` when the lower bound is
        :const:`None` or negative infinity"""
        ...
    
    def has_ub(self): # -> Literal[False]:
        """Returns :const:`False` when the upper bound is
        :const:`None` or positive infinity"""
        ...
    
    def to_bounded_expression(self, evaluate_bounds=...): # -> tuple[Any | None, Any, Any | None] | tuple[Any, Any, Any]:
        ...
    


class _MutableBoundsConstraintMixin:
    """
    Use as a base class for IConstraint implementations
    that allow adjusting the lb, ub, rhs, and equality
    properties.

    Assumes the derived class has _lb, _ub, and _equality
    attributes that can be modified.
    """
    __slots__ = ...
    @property
    def lower(self):
        """The expression for the lower bound of the constraint"""
        ...
    
    @lower.setter
    def lower(self, lb): # -> None:
        ...
    
    @property
    def upper(self):
        """The expression for the upper bound of the constraint"""
        ...
    
    @upper.setter
    def upper(self, ub): # -> None:
        ...
    
    @property
    def lb(self): # -> None:
        """The value of the lower bound of the constraint"""
        ...
    
    @lb.setter
    def lb(self, lb): # -> None:
        ...
    
    @property
    def ub(self): # -> None:
        """The value of the upper bound of the constraint"""
        ...
    
    @ub.setter
    def ub(self, ub): # -> None:
        ...
    
    @property
    def rhs(self):
        """The right-hand side of the constraint"""
        ...
    
    @rhs.setter
    def rhs(self, rhs): # -> None:
        ...
    
    @property
    def bounds(self):
        """The bounds of the constraint as a tuple (lb, ub)"""
        ...
    
    @bounds.setter
    def bounds(self, bounds_tuple): # -> None:
        ...
    
    @property
    def equality(self): # -> bool:
        """Returns :const:`True` when this is an equality
        constraint.

        Disable equality by assigning
        :const:`False`. Equality can only be activated by
        assigning a value to the .rhs property."""
        ...
    
    @equality.setter
    def equality(self, equality): # -> None:
        ...
    


class constraint(_MutableBoundsConstraintMixin, IConstraint):
    """A general algebraic constraint

    Algebraic constraints store relational expressions
    composed of linear or nonlinear functions involving
    decision variables.

    Args:
        expr: Sets the relational expression for the
            constraint. Can be updated later by assigning to
            the :attr:`expr` property on the
            constraint. When this keyword is used, values
            for the :attr:`body`, :attr:`lb`, :attr:`ub`,
            and :attr:`rhs` attributes are automatically
            determined based on the relational expression
            type. Default value is :const:`None`.
        body: Sets the body of the constraint. Can be
            updated later by assigning to the :attr:`body`
            property on the constraint. Default is
            :const:`None`. This keyword should not be used
            in combination with the :attr:`expr` keyword.
        lb: Sets the lower bound of the constraint. Can be
            updated later by assigning to the :attr:`lb`
            property on the constraint. Default is
            :const:`None`, which is equivalent to
            :const:`-inf`. This keyword should not be used
            in combination with the :attr:`expr` keyword.
        ub: Sets the upper bound of the constraint. Can be
            updated later by assigning to the :attr:`ub`
            property on the constraint. Default is
            :const:`None`, which is equivalent to
            :const:`+inf`. This keyword should not be used
            in combination with the :attr:`expr` keyword.
        rhs: Sets the right-hand side of the constraint. Can
            be updated later by assigning to the :attr:`rhs`
            property on the constraint. The default value of
            :const:`None` implies that this keyword is
            ignored. Otherwise, use of this keyword implies
            that the :attr:`equality` property is set to
            :const:`True`. This keyword should not be used
            in combination with the :attr:`expr` keyword.

    Examples:
        >>> import pyomo.kernel as pmo
        >>> # A decision variable used to define constraints
        >>> x = pmo.variable()
        >>> # An upper bound constraint
        >>> c = pmo.constraint(0.5*x <= 1)
        >>> # (equivalent form)
        >>> c = pmo.constraint(body=0.5*x, ub=1)
        >>> # A range constraint
        >>> c = pmo.constraint(lb=-1, body=0.5*x, ub=1)
        >>> # An nonlinear equality constraint
        >>> c = pmo.constraint(x**2 == 1)
        >>> # (equivalent form)
        >>> c = pmo.constraint(body=x**2, rhs=1)
    """
    _ctype = IConstraint
    _linear_canonical_form = ...
    __slots__ = ...
    def __init__(self, expr=..., body=..., lb=..., ub=..., rhs=...) -> None:
        ...
    
    @property
    def body(self): # -> NumericConstant | None:
        """The body of the constraint"""
        ...
    
    @body.setter
    def body(self, body): # -> None:
        ...
    
    @property
    def expr(self): # -> Any | RangedExpression | None:
        """Get or set the expression on this constraint."""
        ...
    
    @expr.setter
    def expr(self, expr):
        ...
    


class linear_constraint(_MutableBoundsConstraintMixin, IConstraint):
    """A linear constraint

    A linear constraint stores a linear relational
    expression defined by a list of variables and
    coefficients. This class can be used to reduce build
    time and memory for an optimization model. It also
    increases the speed at which the model can be output to
    a solver.

    Args:
        variables (list): Sets the list of variables in the
            linear expression defining the body of the
            constraint. Can be updated later by assigning to
            the :attr:`variables` property on the
            constraint.
        coefficients (list): Sets the list of coefficients
            for the variables in the linear expression
            defining the body of the constraint. Can be
            updated later by assigning to the
            :attr:`coefficients` property on the constraint.
        terms (list): An alternative way of initializing the
            :attr:`variables` and :attr:`coefficients` lists
            using an iterable of (variable, coefficient)
            tuples. Can be updated later by assigning to the
            :attr:`terms` property on the constraint. This
            keyword should not be used in combination with
            the :attr:`variables` or :attr:`coefficients`
            keywords.
        lb: Sets the lower bound of the constraint. Can be
            updated later by assigning to the :attr:`lb`
            property on the constraint. Default is
            :const:`None`, which is equivalent to
            :const:`-inf`.
        ub: Sets the upper bound of the constraint. Can be
            updated later by assigning to the :attr:`ub`
            property on the constraint. Default is
            :const:`None`, which is equivalent to
            :const:`+inf`.
        rhs: Sets the right-hand side of the constraint. Can
            be updated later by assigning to the :attr:`rhs`
            property on the constraint. The default value of
            :const:`None` implies that this keyword is
            ignored. Otherwise, use of this keyword implies
            that the :attr:`equality` property is set to
            :const:`True`.

    Examples:
        >>> import pyomo.kernel as pmo
        >>> # Decision variables used to define constraints
        >>> x = pmo.variable()
        >>> y = pmo.variable()
        >>> # An upper bound constraint
        >>> c = pmo.linear_constraint(variables=[x,y], coefficients=[1,2], ub=1)
        >>> # (equivalent form)
        >>> c = pmo.linear_constraint(terms=[(x,1), (y,2)], ub=1)
        >>> # (equivalent form using a general constraint)
        >>> c = pmo.constraint(x + 2*y <= 1)
    """
    _ctype = IConstraint
    _linear_canonical_form = ...
    __slots__ = ...
    def __init__(self, variables=..., coefficients=..., terms=..., lb=..., ub=..., rhs=...) -> None:
        ...
    
    @property
    def terms(self): # -> zip[Any]:
        """An iterator over the terms in the body of this
        constraint as (variable, coefficient) tuples"""
        ...
    
    @terms.setter
    def terms(self, terms): # -> None:
        """Set the terms in the body of this constraint
        using an iterable of (variable, coefficient) tuples"""
        ...
    
    def __call__(self, exception=...): # -> int | None:
        ...
    
    @property
    def body(self): # -> int:
        """The body of the constraint"""
        ...
    
    def canonical_form(self, compute_values=...): # -> StandardRepn:
        """Build a canonical representation of the body of
        this constraints"""
        ...
    


