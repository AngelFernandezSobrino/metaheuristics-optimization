"""
This type stub file was generated by pyright.
"""

from pyomo.core.kernel.constraint import IConstraint

"""Various conic constraint implementations."""
class _ConicBase(IConstraint):
    """Base class for a few conic constraints that
    implements some shared functionality. Derived classes
    are expected to declare any necessary slots."""
    _ctype = IConstraint
    _linear_canonical_form = ...
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    @classmethod
    def as_domain(cls, *args, **kwds):
        """Builds a conic domain"""
        ...
    
    def check_convexity_conditions(self, relax=...):
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    
    @property
    def body(self):
        """The body of the constraint"""
        ...
    
    @property
    def lower(self): # -> None:
        """The expression for the lower bound of the constraint"""
        ...
    
    @property
    def upper(self): # -> float:
        """The expression for the upper bound of the constraint"""
        ...
    
    @property
    def lb(self): # -> None:
        """The value of the lower bound of the constraint"""
        ...
    
    @property
    def ub(self): # -> float:
        """The value of the upper bound of the constraint"""
        ...
    
    @property
    def rhs(self):
        """The right-hand side of the constraint"""
        ...
    
    @property
    def equality(self): # -> Literal[False]:
        ...
    
    def __call__(self, exception=...): # -> None:
        ...
    


class quadratic(_ConicBase):
    """A quadratic conic constraint of the form:

    .. math::

        x[0]^2 + ... + x[n-1]^2 <= r^2,

    which is recognized as convex for r >= 0.

    Parameters
    ----------
    r : :class:`variable`
        A variable.
    x : list[:class:`variable`]
        An iterable of variables.
    """
    __slots__ = ...
    def __init__(self, r, x) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r, x): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x) linked to the input arguments
            through auxiliary constraints (block.c).
        """
        ...
    
    @property
    def r(self): # -> Any:
        ...
    
    @property
    def x(self): # -> tuple[Any, ...]:
        ...
    
    def check_convexity_conditions(self, relax=...): # -> Literal[False]:
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class rotated_quadratic(_ConicBase):
    """A rotated quadratic conic constraint of the form:

    .. math::

        x[0]^2 + ... + x[n-1]^2 <= 2*r1*r2,

    which is recognized as convex for r1,r2 >= 0.

    Parameters
    ----------
    r1 : :class:`variable`
        A variable.
    r2 : :class:`variable`
        A variable.
    x : list[:class:`variable`]
        An iterable of variables.
    """
    __slots__ = ...
    def __init__(self, r1, r2, x) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r1, r2, x): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r1, block.r2, block.x) linked to the
            input arguments through auxiliary constraints
            (block.c).
        """
        ...
    
    @property
    def r1(self): # -> Any:
        ...
    
    @property
    def r2(self): # -> Any:
        ...
    
    @property
    def x(self): # -> tuple[Any, ...]:
        ...
    
    def check_convexity_conditions(self, relax=...): # -> Literal[False]:
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class primal_exponential(_ConicBase):
    """A primal exponential conic constraint of the form:

    .. math::

        x1*exp(x2/x1) <= r,

    which is recognized as convex for x1,r >= 0.

    Parameters
    ----------
    r : :class:`variable`
        A variable.
    x1 : :class:`variable`
        A variable.
    x2 : :class:`variable`
        A variable.
    """
    __slots__ = ...
    def __init__(self, r, x1, x2) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r, x1, x2): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x1, block.x2) linked to the
            input arguments through auxiliary constraints
            (block.c).
        """
        ...
    
    @property
    def r(self): # -> Any:
        ...
    
    @property
    def x1(self): # -> Any:
        ...
    
    @property
    def x2(self): # -> Any:
        ...
    
    def check_convexity_conditions(self, relax=...):
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class primal_power(_ConicBase):
    """A primal power conic constraint of the form:

    .. math::

       sqrt(x[0]^2 + ... + x[n-1]^2) <= (r1^alpha)*(r2^(1-alpha))

    which is recognized as convex for r1,r2 >= 0
    and 0 < alpha < 1.

    Parameters
    ----------
    r1 : :class:`variable`
        A variable.
    r2 : :class:`variable`
        A variable.
    x : list[:class:`variable`]
        An iterable of variables.
    alpha : float, :class:`parameter`, etc.
        A constant term.
    """
    __slots__ = ...
    def __init__(self, r1, r2, x, alpha) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r1, r2, x, alpha): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r1, block.r2, block.x) linked to the
            input arguments through auxiliary constraints
            (block.c).
        """
        ...
    
    @property
    def r1(self): # -> Any:
        ...
    
    @property
    def r2(self): # -> Any:
        ...
    
    @property
    def x(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def alpha(self): # -> Any:
        ...
    
    def check_convexity_conditions(self, relax=...): # -> Literal[False]:
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class primal_geomean(_ConicBase):
    """A primal geometric mean conic constraint of the form:

    .. math::

        (r[0]*...*r[n-2])^(1/(n-1)) >= |x[n-1]|

    Parameters
    ----------
    r : :class:`variable`
        An iterable of variables.
    x : :class:`variable`
        A scalar variable.

    """
    __slots__ = ...
    def __init__(self, r, x) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r, x): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x) linked to the input arguments
            through auxiliary constraints (block.c)."""
        ...
    
    @property
    def r(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def x(self): # -> Any:
        ...
    


class dual_exponential(_ConicBase):
    """A dual exponential conic constraint of the form:

    .. math::

        -x2*exp((x1/x2)-1) <= r

    which is recognized as convex for x2 <= 0 and r >= 0.

    Parameters
    ----------
    r : :class:`variable`
        A variable.
    x1 : :class:`variable`
        A variable.
    x2 : :class:`variable`
        A variable.
    """
    __slots__ = ...
    def __init__(self, r, x1, x2) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r, x1, x2): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x1, block.x2) linked to the
            input arguments through auxiliary constraints
            (block.c).
        """
        ...
    
    @property
    def r(self): # -> Any:
        ...
    
    @property
    def x1(self): # -> Any:
        ...
    
    @property
    def x2(self): # -> Any:
        ...
    
    def check_convexity_conditions(self, relax=...):
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class dual_power(_ConicBase):
    """A dual power conic constraint of the form:

    .. math::

        sqrt(x[0]^2 + ... + x[n-1]^2)
        <=
        ((r1/alpha)^alpha) * ((r2/(1-alpha))^(1-alpha))

    which is recognized as convex for r1,r2 >= 0
    and 0 < alpha < 1.

    Parameters
    ----------
    r1 : :class:`variable`
        A variable.
    r2 : :class:`variable`
        A variable.
    x : list[:class:`variable`]
        An iterable of variables.
    alpha : float, :class:`parameter`, etc.
        A constant term.
    """
    __slots__ = ...
    def __init__(self, r1, r2, x, alpha) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r1, r2, x, alpha): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r1, block.r2, block.x) linked to the
            input arguments through auxiliary constraints
            (block.c).
        """
        ...
    
    @property
    def r1(self): # -> Any:
        ...
    
    @property
    def r2(self): # -> Any:
        ...
    
    @property
    def x(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def alpha(self): # -> Any:
        ...
    
    def check_convexity_conditions(self, relax=...): # -> Literal[False]:
        """Returns True if all convexity conditions for the
        conic constraint are satisfied. If relax is True,
        then variable domains are ignored and it is assumed
        that all variables are continuous."""
        ...
    


class dual_geomean(_ConicBase):
    """A dual geometric mean conic constraint of the form:

    .. math::

        (n-1)*(r[0]*...*r[n-2])^(1/(n-1)) >= |x[n-1]|

    Parameters
    ----------
    r : :class:`variable`
        An iterable of variables.
    x : :class:`variable`
        A scalar variable.

    """
    __slots__ = ...
    def __init__(self, r, x) -> None:
        ...
    
    @classmethod
    def as_domain(cls, r, x): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x) linked to the input arguments
            through auxiliary constraints (block.c)."""
        ...
    
    @property
    def r(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def x(self): # -> Any:
        ...
    


class svec_psdcone(_ConicBase):
    r"""A domain consisting of vectorizations of the lower-triangular
    part of a positive semidefinite matrx, with the non-diagonal
    elements additionally rescaled. In other words, if a vector 'x'
    of length :math:`n = d(d+1)/2` belongs to this cone, then the matrix:

    .. math::

       \begin{array}{rcclcl}
       sMat(x) = [\;\;
          [&      x[1],   &  x[2]/\sqrt{2}, &...,&      x[d]/\sqrt{2} &], \\
          [&x[2]/\sqrt{2},&         x[d+1], &...,&   x[2d-1]/\sqrt{2} &], \\
           &              &    \vdots       &    &                    &   \\
          [&x[d]/\sqrt{2},&x[2d-1]/\sqrt{2},&...,&x[d(d+1)/2]/\sqrt{2}&]
       \;\;]
       \end{array}

    will be restricted to be a positive-semidefinite matrix.

    Parameters
    ----------
    x : :class:`variable`
        An iterable of variables with length :math:`d(d+1)/2`.

    """
    __slots__ = ...
    def __init__(self, x) -> None:
        ...
    
    @classmethod
    def as_domain(cls, x): # -> block:
        """Builds a conic domain. Input arguments take the
        same form as those of the conic constraint, but in
        place of each variable, one can optionally supply a
        constant, linear expression, or None.

        Returns
        -------
        block
            A block object with the core conic constraint
            (block.q) expressed using auxiliary variables
            (block.r, block.x) linked to the input arguments
            through auxiliary constraints (block.c)."""
        ...
    
    @property
    def x(self): # -> tuple[Any, ...]:
        ...
    


