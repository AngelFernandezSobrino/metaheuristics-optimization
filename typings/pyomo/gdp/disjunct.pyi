"""
This type stub file was generated by pyright.
"""

from pyomo.common.deprecation import RenamedClass
from pyomo.common.errors import PyomoException
from pyomo.core import Block, ModelComponentFactory, ScalarBooleanVar, ScalarVar, value
from pyomo.core.base.component import ActiveComponentData
from pyomo.core.base.block import BlockData
from pyomo.core.base.indexed_component import ActiveIndexedComponent

logger = ...
_rule_returned_none_error = ...
class GDP_Error(PyomoException):
    """Exception raised while processing GDP Models"""
    ...


class AutoLinkedBinaryVar(ScalarVar):
    """A binary variable implicitly linked to its equivalent Boolean variable.

    Basic operations like setting values and fixing/unfixing this
    variable are also automatically applied to the associated Boolean
    variable.

    As this class is only intended to provide a deprecation path for
    Disjunct.indicator_var, it only supports Scalar instances and does
    not support indexing.
    """
    INTEGER_TOLERANCE = ...
    __autoslot_mappers__ = ...
    def __init__(self, boolean_var=...) -> None:
        ...
    
    def get_associated_boolean(self): # -> None:
        ...
    
    def set_value(self, val, skip_validation=..., _propagate_value=...): # -> None:
        ...
    
    def fix(self, value=..., skip_validation=...): # -> None:
        ...
    
    def unfix(self): # -> None:
        ...
    


class AutoLinkedBooleanVar(ScalarBooleanVar):
    """A Boolean variable implicitly linked to its equivalent binary variable.

    This class provides a deprecation path for GDP.  Originally,
    Disjunct indicator_var was a binary variable.  This simplified early
    transformations.  However, with the introduction of a proper logical
    expression system, the mathematically correct approach is for the
    Disjunct's indicator_var attribute to be a proper BooleanVar.  As
    part of the transition, indicator_var attributes are instances of
    AutoLinkedBooleanVar, which allow the indicator_var to be used in
    logical expressions, but also implicitly converted (with deprecation
    warning) into their equivalent binary variable.

    Basic operations like setting values and fixing/unfixing this
    variable are also automatically applied to the associated binary
    variable.

    As this class is only intended to provide a deprecation path for
    Disjunct.indicator_var, it only supports Scalar instances and does
    not support indexing.

    """
    def as_numeric(self): # -> None:
        """Return the binary variable associated with this Boolean variable.

        This method returns the associated binary variable along with a
        deprecation warning about using the Boolean variable in a numeric
        context.

        """
        ...
    
    def as_binary(self): # -> None:
        ...
    
    def set_value(self, val, skip_validation=..., _propagate_value=...): # -> None:
        ...
    
    def fix(self, value=..., skip_validation=...): # -> None:
        ...
    
    def unfix(self): # -> None:
        ...
    
    @property
    def bounds(self):
        ...
    
    @bounds.setter
    def bounds(self, value): # -> None:
        ...
    
    @property
    def lb(self):
        ...
    
    @lb.setter
    def lb(self, value): # -> None:
        ...
    
    @property
    def ub(self):
        ...
    
    @ub.setter
    def ub(self, value): # -> None:
        ...
    
    def __abs__(self):
        ...
    
    def __float__(self):
        ...
    
    def __int__(self) -> int:
        ...
    
    def __neg__(self):
        ...
    
    def __bool__(self): # -> Literal[False]:
        ...
    
    def __pos__(self):
        ...
    
    def get_units(self):
        ...
    
    def has_lb(self):
        ...
    
    def has_ub(self):
        ...
    
    def is_binary(self):
        ...
    
    def is_continuous(self):
        ...
    
    def is_integer(self):
        ...
    
    def polynomial_degree(self):
        ...
    
    def __le__(self, arg) -> bool:
        ...
    
    def __lt__(self, arg) -> bool:
        ...
    
    def __ge__(self, arg) -> bool:
        ...
    
    def __gt__(self, arg) -> bool:
        ...
    
    def __eq__(self, arg) -> bool:
        ...
    
    def __ne__(self, arg) -> bool:
        ...
    
    def __add__(self, arg): # -> _NotImplementedType:
        ...
    
    def __div__(self, arg): # -> _NotImplementedType:
        ...
    
    def __mul__(self, arg): # -> _NotImplementedType:
        ...
    
    def __pow__(self, arg): # -> _NotImplementedType:
        ...
    
    def __sub__(self, arg): # -> _NotImplementedType:
        ...
    
    def __truediv__(self, arg): # -> _NotImplementedType:
        ...
    
    def __iadd__(self, arg): # -> _NotImplementedType:
        ...
    
    def __idiv__(self, arg): # -> _NotImplementedType:
        ...
    
    def __imul__(self, arg): # -> _NotImplementedType:
        ...
    
    def __ipow__(self, arg): # -> _NotImplementedType:
        ...
    
    def __isub__(self, arg): # -> _NotImplementedType:
        ...
    
    def __itruediv__(self, arg): # -> _NotImplementedType:
        ...
    
    def __radd__(self, arg): # -> _NotImplementedType:
        ...
    
    def __rdiv__(self, arg): # -> _NotImplementedType:
        ...
    
    def __rmul__(self, arg): # -> _NotImplementedType:
        ...
    
    def __rpow__(self, arg): # -> _NotImplementedType:
        ...
    
    def __rsub__(self, arg): # -> _NotImplementedType:
        ...
    
    def __rtruediv__(self, arg): # -> _NotImplementedType:
        ...
    
    def setlb(self, arg):
        ...
    
    def setub(self, arg):
        ...
    


class _Initializer:
    """A simple function to process an argument to a Component constructor.

    This checks the incoming initializer type and maps it to a static
    identifier so that when constructing indexed Components we can avoid
    a series of isinstance calls.  Eventually this concept should be
    promoted to pyomo.core so that all Components can leverage a
    standardized approach to processing "flexible" arguments (POD data,
    rules, dicts, generators, etc)."""
    value = ...
    deferred_value = ...
    function = ...
    dict_like = ...
    @staticmethod
    def process(arg): # -> tuple[int, bool] | tuple[int, FunctionType] | tuple[int, ComponentData] | tuple[int, Any]:
        ...
    


class DisjunctData(BlockData):
    __autoslot_mappers__ = ...
    _Block_reserved_words = ...
    @property
    def transformation_block(self): # -> None:
        ...
    
    def __init__(self, component) -> None:
        ...
    
    def activate(self): # -> None:
        ...
    
    def deactivate(self): # -> None:
        ...
    


class _DisjunctData(metaclass=RenamedClass):
    __renamed__new_class__ = DisjunctData
    __renamed__version__ = ...


@ModelComponentFactory.register("Disjunctive blocks.")
class Disjunct(Block):
    _ComponentDataClass = DisjunctData
    def __new__(cls, *args, **kwds): # -> Self:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class ScalarDisjunct(DisjunctData, Disjunct):
    def __init__(self, *args, **kwds) -> None:
        ...
    


class SimpleDisjunct(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarDisjunct
    __renamed__version__ = ...


class IndexedDisjunct(Disjunct):
    @property
    def active(self): # -> bool:
        ...
    


class DisjunctionData(ActiveComponentData):
    __slots__ = ...
    __autoslot_mappers__ = ...
    _NoArgument = ...
    @property
    def algebraic_constraint(self): # -> None:
        ...
    
    def __init__(self, component=...) -> None:
        ...
    
    def set_value(self, expr): # -> None:
        ...
    


class _DisjunctionData(metaclass=RenamedClass):
    __renamed__new_class__ = DisjunctionData
    __renamed__version__ = ...


@ModelComponentFactory.register("Disjunction expressions.")
class Disjunction(ActiveIndexedComponent):
    _ComponentDataClass = DisjunctionData
    def __new__(cls, *args, **kwds): # -> Self:
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def construct(self, data=...): # -> None:
        ...
    


class ScalarDisjunction(DisjunctionData, Disjunction):
    def __init__(self, *args, **kwds) -> None:
        ...
    
    def set_value(self, expr): # -> None:
        """Set the expression on this disjunction."""
        ...
    


class SimpleDisjunction(metaclass=RenamedClass):
    __renamed__new_class__ = ScalarDisjunction
    __renamed__version__ = ...


class IndexedDisjunction(Disjunction):
    @property
    def active(self): # -> bool:
        ...
    


