"""
This type stub file was generated by pyright.
"""

logger = ...
inf = ...
class _bool_flag:
    def __init__(self, val) -> None:
        ...
    
    def __bool__(self): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    __float__ = ...
    __int__ = ...
    __abs__ = ...
    __neg__ = ...
    __add__ = ...
    __sub__ = ...
    __mul__ = ...
    __div__ = ...
    __pow__ = ...
    __radd__ = ...
    __rsub__ = ...
    __rmul__ = ...
    __rdiv__ = ...
    __rpow__ = ...


_true = ...
_false = ...
def BoolFlag(val): # -> _bool_flag:
    ...

def ineq(xl, xu, yl, yu, feasibility_tol): # -> tuple[Any, ...]:
    """Compute the "bounds" on an InequalityExpression

    Note this is *not* performing interval arithmetic: we are
    calculating the "bounds" on a RelationalExpression (whose domain is
    {True, False}).  Therefore we are determining if `x` can be less
    than `y`, `x` can not be less than `y`, or both.

    """
    ...

def eq(xl, xu, yl, yu, feasibility_tol): # -> tuple[Any, ...]:
    """Compute the "bounds" on an EqualityExpression

    Note this is *not* performing interval arithmetic: we are
    calculating the "bounds" on a RelationalExpression (whose domain is
    {True, False}).  Therefore we are determining if `x` can be equal to
    `y`, `x` can not be equal to `y`, or both.

    """
    ...

def ranged(xl, xu, yl, yu, zl, zu, feasibility_tol): # -> tuple[Any, ...]:
    """Compute the "bounds" on a RangedExpression

    Note this is *not* performing interval arithmetic: we are
    calculating the "bounds" on a RelationalExpression (whose domain is
    {True, False}).  Therefore we are determining if `y` can be between
    `z` and `z`, `y` can be outside the range `x` and `z`, or both.

    """
    ...

def if_(il, iu, tl, tu, fl, fu): # -> tuple[Any, Any]:
    ...

def add(xl, xu, yl, yu): # -> tuple[Any, Any]:
    ...

def sub(xl, xu, yl, yu): # -> tuple[Any, Any]:
    ...

def mul(xl, xu, yl, yu): # -> tuple[float, float] | tuple[float | Any, float | Any]:
    ...

def inv(xl, xu, feasibility_tol): # -> tuple[float | Any, float | Any]:
    """Compute the inverse of an interval

    The case where xl is very slightly positive but should be very
    slightly negative (or xu is very slightly negative but should be
    very slightly positive) should not be an issue. Suppose xu is 2 and
    xl is 1e-15 but should be -1e-15.  The bounds obtained from this
    function will be [0.5, 1e15] or [0.5, inf), depending on the value
    of feasibility_tol. The true bounds are (-inf, -1e15] U [0.5, inf),
    where U is union. The exclusion of (-inf, -1e15] should be
    acceptable. Additionally, it very important to return a non-negative
    interval when xl is non-negative.

    """
    ...

def div(xl, xu, yl, yu, feasibility_tol): # -> tuple[float, float] | tuple[float | Any, float | Any]:
    ...

def power(xl, xu, yl, yu, feasibility_tol): # -> tuple[Any | float | Literal[0], Any | float]:
    """
    Compute bounds on x**y.
    """
    ...

def interval_abs(xl, xu): # -> tuple[Any | Literal[0], Any]:
    ...

def exp(xl, xu): # -> tuple[float, float]:
    ...

def log(xl, xu): # -> tuple[float, float]:
    ...

def log10(xl, xu): # -> tuple[float, float]:
    ...

def sin(xl, xu): # -> tuple[Literal[-1], Literal[1]] | tuple[float | Literal[-1], float | Literal[1]]:
    """

    Parameters
    ----------
    xl: float
    xu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

def cos(xl, xu): # -> tuple[Literal[-1], Literal[1]] | tuple[float | Literal[-1], float | Literal[1]]:
    """

    Parameters
    ----------
    xl: float
    xu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

def tan(xl, xu): # -> tuple[float, float]:
    """

    Parameters
    ----------
    xl: float
    xu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

def asin(xl, xu, yl, yu, feasibility_tol): # -> tuple[Any, Any]:
    """
    y = asin(x); propagate bounds from x to y
    x = sin(y)

    Parameters
    ----------
    xl: float
    xu: float
    yl: float
    yu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

def acos(xl, xu, yl, yu, feasibility_tol): # -> tuple[Any, Any]:
    """
    y = acos(x); propagate bounds from x to y
    x = cos(y)

    Parameters
    ----------
    xl: float
    xu: float
    yl: float
    yu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

def atan(xl, xu, yl, yu): # -> tuple[Any, Any]:
    """
    y = atan(x); propagate bounds from x to y
    x = tan(y)

    Parameters
    ----------
    xl: float
    xu: float
    yl: float
    yu: float

    Returns
    -------
    lb: float
    ub: float
    """
    ...

