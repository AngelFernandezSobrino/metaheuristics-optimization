"""
This type stub file was generated by pyright.
"""

from pyomo.core.expr.visitor import ExpressionValueVisitor, StreamBasedExpressionVisitor
from pyomo.common.errors import PyomoException

logger = ...
__doc__ = ...
class FBBTException(PyomoException):
    ...


_unary_leaf_to_root_map = ...
_prop_bnds_leaf_to_root_map = ...
_unary_root_to_leaf_map = ...
_prop_bnds_root_to_leaf_map = ...
_before_child_handlers = ...
class _FBBTVisitorLeafToRoot(StreamBasedExpressionVisitor):
    """
    This walker propagates bounds from the variables to each node in
    the expression tree (all the way to the root node).
    """
    def __init__(self, bnds_dict, integer_tol=..., feasibility_tol=..., ignore_fixed=...) -> None:
        """
        Parameters
        ----------
        bnds_dict: ComponentMap
        integer_tol: float
        feasibility_tol: float
            If the bounds computed on the body of a constraint violate the bounds of
            the constraint by more than feasibility_tol, then the constraint is
            considered infeasible and an exception is raised. This tolerance is also
            used when performing certain interval arithmetic operations to ensure that
            none of the feasible region is removed due to floating point arithmetic and
            to prevent math domain errors (a larger value is more conservative).
        """
        ...
    
    def initializeWalker(self, expr): # -> tuple[Literal[False], Any] | tuple[Literal[True], Any]:
        ...
    
    def beforeChild(self, node, child, child_idx):
        ...
    
    def exitNode(self, node, data): # -> None:
        ...
    


class _FBBTVisitorRootToLeaf(ExpressionValueVisitor):
    """
    This walker propagates bounds from the constraint back to the
    variables. Note that the bounds on every node in the tree must
    first be computed with _FBBTVisitorLeafToRoot.
    """
    def __init__(self, bnds_dict, integer_tol=..., feasibility_tol=...) -> None:
        """
        Parameters
        ----------
        bnds_dict: ComponentMap
        integer_tol: float
        feasibility_tol: float
            If the bounds computed on the body of a constraint violate the bounds of the constraint by more than
            feasibility_tol, then the constraint is considered infeasible and an exception is raised. This tolerance
            is also used when performing certain interval arithmetic operations to ensure that none of the feasible
            region is removed due to floating point arithmetic and to prevent math domain errors (a larger value
            is more conservative).
        """
        ...
    
    def visit(self, node, values): # -> None:
        ...
    
    def visiting_potential_leaf(self, node): # -> tuple[Literal[True], None] | tuple[Literal[False], None]:
        ...
    


def fbbt(comp, deactivate_satisfied_constraints=..., integer_tol=..., feasibility_tol=..., max_iter=..., improvement_tol=..., descend_into=...): # -> ComponentMap:
    """
    Perform FBBT on a constraint, block, or model. For more control,
    use _fbbt_con and _fbbt_block. For detailed documentation, see
    the docstrings for _fbbt_con and _fbbt_block.

    Parameters
    ----------
    comp: pyomo.core.base.constraint.Constraint or pyomo.core.base.block.Block or pyomo.core.base.PyomoModel.ConcreteModel
    deactivate_satisfied_constraints: bool
        If deactivate_satisfied_constraints is True and a constraint is always satisfied, then the constranit
        will be deactivated
    integer_tol: float
        If the lower bound computed on a binary variable is less than or equal to integer_tol, then the
        lower bound is left at 0. Otherwise, the lower bound is increased to 1. If the upper bound computed
        on a binary variable is greater than or equal to 1-integer_tol, then the upper bound is left at 1.
        Otherwise the upper bound is decreased to 0.
    feasibility_tol: float
        If the bounds computed on the body of a constraint violate the bounds of the constraint by more than
        feasibility_tol, then the constraint is considered infeasible and an exception is raised. This tolerance
        is also used when performing certain interval arithmetic operations to ensure that none of the feasible
        region is removed due to floating point arithmetic and to prevent math domain errors (a larger value
        is more conservative).
    max_iter: int
        Used for Blocks only (i.e., comp.ctype == Block). When performing FBBT on a Block, we first perform FBBT on
        every constraint in the Block. We then attempt to identify which constraints to repeat FBBT on based on the
        improvement in variable bounds. If the bounds on a variable improve by more than improvement_tol, then FBBT
        is performed on the constraints using that Var. However, this algorithm is not guaranteed to converge, so
        max_iter limits the total number of times FBBT is performed to max_iter times the number of constraints
        in the Block.
    improvement_tol: float
        Used for Blocks only (i.e., comp.ctype == Block). When performing FBBT on a Block, we first perform FBBT on
        every constraint in the Block. We then attempt to identify which constraints to repeat FBBT on based on the
        improvement in variable bounds. If the bounds on a variable improve by more than improvement_tol, then FBBT
        is performed on the constraints using that Var.

    Returns
    -------
    new_var_bounds: ComponentMap
        A ComponentMap mapping from variables a tuple containing the lower and upper bounds, respectively, computed
        from FBBT.
    """
    ...

def compute_bounds_on_expr(expr, ignore_fixed=...): # -> tuple[Any | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | list[Any] | None, Any | tuple[()] | int | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[Any | tuple[Any | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | tuple[()] | int, ...] | list[Any] | None]:
    """
    Compute bounds on an expression based on the bounds on the variables in
    the expression.

    Parameters
    ----------
    expr: pyomo.core.expr.numeric_expr.NumericExpression
    ignore_fixed: bool, treats fixed Vars as constants if False, else treats
                  them as Vars

    Returns
    -------
    lb: float
    ub: float
    """
    ...

class BoundsManager:
    def __init__(self, comp) -> None:
        ...
    
    def save_bounds(self): # -> None:
        ...
    
    def pop_bounds(self, ndx=...): # -> None:
        ...
    
    def load_bounds(self, bnds, save_current_bounds=...): # -> None:
        ...
    


