"""
This type stub file was generated by pyright.
"""

import types
from pyomo.common.flags import building_documentation, in_testing_environment

"""This module provides utilities for deprecating functionality.

.. autosummary::

   deprecated
   deprecation_warning
   relocated_module
   relocated_module_attribute
   RenamedClass
"""
_doc_flag = ...
def default_deprecation_msg(obj, user_msg, version, remove_in): # -> str:
    """Generate the default deprecation message.

    See deprecated() function for argument details.
    """
    ...

def deprecation_warning(msg, logger=..., version=..., remove_in=..., calling_frame=...): # -> None:
    """Standardized formatter for deprecation warnings

    This is a standardized routine for formatting deprecation warnings
    so that things look consistent and "nice".

    Args:
        msg (str): the deprecation message to format

        logger (str): the logger to use for emitting the warning
            (default: the calling pyomo package, or "pyomo")

        version (str): [required] the version in which the decorated
            object was deprecated.  General practice is to set version
            to the current development version (from `pyomo --version`)
            during development and update it to the actual release as
            part of the release process.

        remove_in (str): the version in which the decorated object will be
            removed from the code.

        calling_frame (frame): the original frame context that triggered
            the deprecation warning.

    Example
    -------
    >>> from pyomo.common.deprecation import deprecation_warning
    >>> deprecation_warning('This functionality is deprecated.', version='1.2.3')
    WARNING: DEPRECATED: This functionality is deprecated.  (deprecated in 1.2.3) ...

    """
    ...

if in_testing_environment() or building_documentation():
    ...
else:
    ...
def deprecated(msg=..., logger=..., version=..., remove_in=...): # -> Callable[..., Any | _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """Decorator to indicate that a function, method, or class is deprecated.

    This decorator will cause a warning to be logged when the wrapped
    function or method is called, or when the deprecated class is
    constructed.  This decorator also updates the target object's
    docstring to indicate that it is deprecated.

    Args:
        msg (str): a custom deprecation message (default: "This
            {function|class} has been deprecated and may be
            removed in a future release.")

        logger (str): the logger to use for emitting the warning
            (default: the calling pyomo package, or "pyomo")

        version (str): [required] the version in which the decorated
            object was deprecated.  General practice is to set version
            to the current development version (from `pyomo --version`)
            during development and update it to the actual release as
            part of the release process.

        remove_in (str): the version in which the decorated object will be
            removed from the code.

    Example
    -------
    >>> from pyomo.common.deprecation import deprecated
    >>> @deprecated(version='1.2.3')
    ... def sample_function(x):
    ...     return 2*x
    >>> sample_function(5)
    WARNING: DEPRECATED: This function (sample_function) has been deprecated and
        may be removed in a future release.  (deprecated in 1.2.3) ...
    10

    """
    ...

@deprecated("relocated_module() has been deprecated.  Please use moved_module()", version='6.8.1')
def relocated_module(new_name, msg=..., logger=..., version=..., remove_in=...): # -> None:
    """Provide a deprecation path for moved / renamed modules

    Upon import, the old module (that called `relocated_module()`) will
    be replaced in :data:`sys.modules` by an alias that points directly to the
    new module.  As a result, the old module should have only two lines
    of executable Python code (the import of `relocated_module` and the
    call to it).

    Note
    ----
    This method (which was placed in the old module that is
    being removed) is deprecated and should be replaced by calls to
    :func:`moved_module()`, which can be called in any parent scope of
    the removed module and does not require that the old module continue
    to exist in the project.

    Parameters
    ----------
    new_name: str
        The new (fully-qualified) module name

    msg: str
        A custom deprecation message.

    logger: str
        The logger to use for emitting the warning (default: the calling
        pyomo package, or "pyomo")

    version: str [required]
        The version in which the module was renamed or moved.  General
        practice is to set version to the current development version
        (from `pyomo --version`) during development and update it to the
        actual release as part of the release process.

    remove_in: str
        The version in which the module will be removed from the code.

    Example
    -------
    >>> from pyomo.common.deprecation import relocated_module
    >>> relocated_module('pyomo.common.deprecation', version='1.2.3')
    WARNING: DEPRECATED: ... The '...' module has been moved to
        'pyomo.common.deprecation'. Please update your import.
        (deprecated in 1.2.3) ...

    """
    ...

def relocated_module_attribute(local, target, version, remove_in=..., msg=..., f_globals=...): # -> None:
    """Provide a deprecation path for moved / renamed module attributes

    This function declares that a local module attribute has been moved
    to another location.  For Python 3.7+, it leverages a
    module.__getattr__ method to manage the deferred import of the
    object from the new location (on request), as well as emitting the
    deprecation warning.

    Parameters
    ----------
    local: str
        The original (local) name of the relocated attribute

    target: str
        The new absolute import name of the relocated attribute

    version: str
        The Pyomo version when this move was released
        (passed to deprecation_warning)

    remove_in: str
        The Pyomo version when this deprecation path will be removed
        (passed to deprecation_warning)

    msg: str
        If not None, then this specifies a custom deprecation message to
        be emitted when the attribute is accessed from its original
        location.

    """
    ...

class RenamedClass(type):
    """Metaclass to provide a deprecation path for renamed classes

    This metaclass provides a mechanism for renaming old classes while
    still preserving isinstance / issubclass relationships.

    Examples
    --------
    >>> from pyomo.common.deprecation import RenamedClass
    >>> class NewClass(object):
    ...     pass
    >>> class OldClass(metaclass=RenamedClass):
    ...     __renamed__new_class__ = NewClass
    ...     __renamed__version__ = '6.0'

    Deriving from the old class generates a warning:

    >>> class DerivedOldClass(OldClass):
    ...     pass
    WARNING: DEPRECATED: Declaring class 'DerivedOldClass' derived from
        'OldClass'. The class 'OldClass' has been renamed to 'NewClass'.
        (deprecated in 6.0) ...

    As does instantiating the old class:

    >>> old = OldClass()
    WARNING: DEPRECATED: Instantiating class 'OldClass'.  The class
        'OldClass' has been renamed to 'NewClass'.  (deprecated in 6.0) ...

    Finally, `isinstance` and `issubclass` still work, for example:

    >>> isinstance(old, NewClass)
    True
    >>> class NewSubclass(NewClass):
    ...     pass
    >>> new = NewSubclass()
    >>> isinstance(new, OldClass)
    WARNING: DEPRECATED: Checking type relative to 'OldClass'.  The class
        'OldClass' has been renamed to 'NewClass'.  (deprecated in 6.0) ...
    True

    """
    def __new__(cls, name, bases, classdict, *args, **kwargs): # -> Self:
        ...
    
    def __instancecheck__(cls, instance): # -> bool:
        ...
    
    def __subclasscheck__(cls, subclass): # -> bool:
        ...
    


class MovedModuleLoader:
    """Custom module loader that supports loading modules through alternate names

    This class implements the :class:`importlib.abc.Loader` interface
    (through duck-typing to avoid a surprisingly costly import of
    :mod:`importlib.abc`).  Calls to :meth:`create_module()` and
    :meth:`exec_module()` are delegated to corresponding methods on the
    loader for the new module name.

    """
    def __init__(self, info) -> None:
        ...
    
    def create_module(self, spec) -> types.ModuleType:
        ...
    
    def exec_module(self, module: types.ModuleType) -> None:
        ...
    


class MovedModuleFinder:
    """Custom finder that supports loading a module through an alternative name.

    This class implements the :class:`importlib.abc.Finder` interface
    (through duck-typing to avoid a surprisingly costly import of
    :mod:`importlib.abc`).

    Pyomo automatically registers a single instance of this finder with
    :mod:`importlib` by appending it to the end of the
    :data:`sys.meta_path` list when this module is imported.
    Subsequent calls to :func:`moved_module` register the association
    between the old and new module names with the ``mapping`` class
    attribute.

    """
    mapping = ...
    def find_spec(self, fullname, path, target=...): # -> None:
        ...
    
    def invalidate_caches(self): # -> None:
        ...
    


MovedModuleInfo = ...
def moved_module(old_name, new_name, msg=..., logger=..., version=..., remove_in=...): # -> None:
    """Provide a deprecation path for moved / renamed modules

    This function hooks into the Python :mod:`importlib` to cause any
    import of the ``old_name`` to instead import and return the module
    from ``new_name``.  The new module is automatically registered with
    :data:`sys.modules` under both the old and new names.

    Because :func:`moved_module()` works through the Python
    :mod:`importlib` system, the old module file can be completely
    deleted (in contrast to the [deprecated] :func:`relocated_module()`
    function).  Calls to :func:`moved_module` should be placed in any
    package above the removed module in the package hierarchy (or in any
    other location that is guaranteeded to be imported / executed before
    any attempts at importng the module through its old name.

    Any import of the module through the old name will emit a
    deprecation warning unless the ``msg`` is ``None`` (see also
    :func:`deprecated`).

    Parameters
    ----------
    old_name: str
        The original (fully-qualified) module name (that has been removed)

    new_name: str
        The new (fully-qualified) module name

    msg: str
        A custom deprecation message.  If None, the deprecation message
        will be suppressed.  If NOTSET (default), a generic deprecation
        message will be logged.

    logger: str
        The logger to use for emitting the warning (default: the calling
        pyomo package, or "pyomo")

    version: str [required]
        The version in which the module was renamed or moved.  General
        practice is to set version to the current development version
        (from `pyomo --version`) during development and update it to the
        actual release as part of the release process.

    remove_in: str
        The version in which the module will be removed from the code.

    Example
    -------
    >>> from pyomo.common.deprecation import moved_module
    >>> moved_module(
    ...     'pyomo.common.old_deprecation',
    ...     'pyomo.common.deprecation',
    ...     version='1.2.3',
    ... )
    >>> import pyomo.common.old_deprecation
    WARNING: DEPRECATED: The 'pyomo.common.old_deprecation' module has
        been moved to 'pyomo.common.deprecation'. Please update your import.
        (deprecated in 1.2.3) ...
    >>> import pyomo.common.deprecation
    >>> pyomo.common.old_deprecation is pyomo.common.deprecation
    True

    """
    ...

