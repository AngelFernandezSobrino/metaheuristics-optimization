"""
This type stub file was generated by pyright.
"""

_poll_interval = ...
_poll_rampup_limit = ...
_poll_rampup = ...
_poll_timeout = ...
_poll_timeout_deadlock = ...
_mswindows = ...
if _mswindows:
    ...
else:
    ...
_peek_available = ...
logger = ...
class redirect_fd:
    """Redirect a file descriptor to a new file or file descriptor.

    This context manager will redirect the specified file descriptor to
    a specified new output target (either file name or file descriptor).
    For the special case of file descriptors 1 (stdout) and 2 (stderr),
    we will also make sure that the Python `sys.stdout` or `sys.stderr`
    remain usable: in the case of synchronize=True, the `sys.stdout` /
    `sys.stderr` file handles point to the new file descriptor.  When
    synchronize=False, we preserve the behavior of the Python file
    object (retargeting it to the original file descriptor if necessary).

    Parameters
    ----------
    fd: int
        The file descriptor to redirect

    output: int or str
        The new output target for `fd`: either another valid file
        descriptor (int) or a string with the file to open.

    synchronize: bool
        If True, and `fd` is 1 or 2, then update `sys.stdout` or
        `sys.stderr` to also point to the new file descriptor
    """
    def __init__(self, fd=..., output=..., synchronize=...) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, t, v, traceback): # -> None:
        ...
    


class capture_output:
    """
    Drop-in substitute for PyUtilib's capture_output.
    Takes in a StringIO, file-like object, or filename and temporarily
    redirects output to a string buffer.
    """
    def __init__(self, output=..., capture_fd=...) -> None:
        ...
    
    def __enter__(self): # -> TextIOWrapper[_WrappedBuffer] | StringIO:
        ...
    
    def __exit__(self, et, ev, tb): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def setup(self): # -> TextIOWrapper[_WrappedBuffer] | StringIO:
        ...
    
    def reset(self): # -> None:
        ...
    


class _StreamHandle:
    def __init__(self, mode, buffering, encoding, newline) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def fileno(self): # -> int:
        ...
    
    def close(self): # -> None:
        ...
    
    def finalize(self, ostreams): # -> None:
        ...
    
    def decodeIncomingBuffer(self): # -> None:
        ...
    
    def writeOutputBuffer(self, ostreams): # -> None:
        ...
    


class TeeStream:
    def __init__(self, *ostreams, encoding=...) -> None:
        ...
    
    @property
    def STDOUT(self): # -> TextIOWrapper[_WrappedBuffer] | None:
        ...
    
    @property
    def STDERR(self): # -> TextIOWrapper[_WrappedBuffer] | None:
        ...
    
    def open(self, mode=..., buffering=..., encoding=..., newline=...): # -> TextIOWrapper[_WrappedBuffer] | None:
        ...
    
    def close(self, in_exception=...): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, et, ev, tb): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    


