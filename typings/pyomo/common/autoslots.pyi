"""
This type stub file was generated by pyright.
"""

import collections

_autoslot_info = ...
class _DeepcopyDispatcher(collections.defaultdict):
    def __missing__(self, key): # -> Callable[..., Any]:
        ...
    


_deepcopy_dispatcher = ...
_atomic_types = ...
def fast_deepcopy(obj, memo):
    """A faster implementation of copy.deepcopy()

    Python's default implementation of deepcopy has several features that
    are slower than they need to be.  This is an implementation of
    deepcopy that provides special handling to circumvent some of the
    slowest parts of deepcopy().

    Note
    ----

    This implementation is not as aggressive about keeping the copied
    state alive until the end of the deepcopy operation.  In particular,
    the ``dict``, ``list`` and ``tuple`` handlers do not register their
    source objects with the memo.  This is acceptable, as
    fast_deepcopy() is only called in situations where we are ensuring
    that the source object will persist:

    - :meth:`AutoSlots.__deepcopy_state__` explicitly preserved the
      source state
    - :meth:`Component.__deepcopy_field__` is only called by
      :meth:`AutoSlots.__deepcopy_state__` -
    - :meth:`IndexedComponent._create_objects_for_deepcopy` is
      deepcopying the raw keys from the source ``_data`` dict (which is
      not a temporary object and will persist)

    If other consumers wish to make use of this function (e.g., within
    their implementation of ``__deepcopy__``), they must remember that
    they are responsible to ensure that any temporary source ``obj``
    persists.

    """
    ...

class AutoSlots(type):
    """Metaclass to automatically collect `__slots__` for generic pickling

    The class `__slots__` are collected in reverse MRO order.

    Any fields that require special handling are handled through
    callbacks specified through the `__autoslot_mappers__` class
    attribute.  `__autoslot_mappers__` should be a `dict` that maps the
    field name (either `__slot__` or regular `__dict__` entry) to a
    function with the signature:

        mapper(encode: bool, val: Any) -> Any

    The value from the object field (or state) is passed to the mapper
    function, and the function returns the corrected value.
    `__getstate__` calls the mapper with `encode=True`, and
    `__setstate__` calls the mapper with `encode=False`.
    `__autoslot_mappers__` class attributes are collected and combined
    in reverse MRO order (so duplicate mappers in more derived classes
    will replace mappers defined in base classes).

    :py:class:`AutoSlots` defines several common mapper functions, including:

      - :py:meth:`AutoSlots.weakref_mapper`
      - :py:meth:`AutoSlots.weakref_sequence_mapper`
      - :py:meth:`AutoSlots.encode_as_none`

    Result
    ~~~~~~

    This metaclass will add a `__auto_slots__` class attribute to the
    class (and all derived classes).  This attribute is an instance of a
    :py:class:`_autoslot_info` named 4-tuple:

       (has_dict, slots, slot_mappers, field_mappers)

    has_dict: bool
        True if this class has a `__dict__` attribute (that would need to
        be pickled in addition to the `__slots__`)

    slots: tuple
        Tuple of all slots declared for this class (the union of any
        slots declared locally with all slots declared on any base class)

    slot_mappers: dict
        Dict mapping index in `slots` to a function with signature
        `mapper(encode: bool, val: Any)` that can be used to encode or
        decode that slot

    field_mappers: dict
        Dict mapping field name in `__dict__` to a function with signature
        `mapper(encode: bool, val: Any)` that can be used to encode or
        decode that field value.

    """
    _ignore_slots = ...
    def __init__(cls, name, bases, classdict) -> None:
        ...
    
    @staticmethod
    def collect_autoslots(cls): # -> None:
        ...
    
    @staticmethod
    def weakref_mapper(encode, val): # -> ReferenceType[Any]:
        """__autoslot_mappers__ mapper for fields that contain weakrefs

        This mapper expects to be passed a field containing either a
        weakref or None.  It will resolve the weakref to a hard
        reference when generating a state, and then convert the hard
        reference back to a weakref when restoring the state.

        """
        ...
    
    @staticmethod
    def weakref_sequence_mapper(encode, val):
        """__autoslot_mappers__ mapper for fields with sequences of weakrefs

        This mapper expects to be passed a field that is a sequence of
        weakrefs.  It will resolve all weakrefs when generating a state,
        and then convert the hard references back to a weakref when
        restoring the state.

        """
        ...
    
    @staticmethod
    def encode_as_none(encode, val): # -> None:
        """__autoslot_mappers__ mapper that will replace fields with None

        This mapper will encode the field as None (regardless of the
        current field value).  No mapping occurs when restoring a state.

        """
        ...
    
    class Mixin:
        """Mixin class to configure a class hierarchy to use AutoSlots

        Inheriting from this class will set up the automatic generation
        of the `__auto_slots__` class attribute, and define the standard
        implementations for `__deepcopy__`, `__getstate__`, and
        `__setstate__`.

        """
        __slots__ = ...
        def __init_subclass__(cls, **kwds): # -> None:
            """Automatically define `__auto_slots__` on derived subclasses

            This accomplishes the same thing as the AutoSlots metaclass
            without incurring the overhead / runtime penalty of using a
            metaclass.

            """
            ...
        
        def __deepcopy__(self, memo): # -> Self:
            """Default implementation of `__deepcopy__` based on `__getstate__`

            This defines a default implementation of `__deepcopy__` that
            leverages :py:meth:`__getstate__` and :py:meth:`__setstate__`
            to duplicate an object.  Having a default `__deepcopy__`
            implementation shortcuts significant logic in
            :py:func:`copy.deepcopy()`, thereby speeding up deepcopy
            operations.

            """
            ...
        
        def __deepcopy_state__(self, memo, new_object): # -> None:
            """This implements the state copy from a source object to the new
            instance in the deepcopy memo.

            This splits out the logic for actually duplicating the
            object state from the "boilerplate" that creates a new
            object and registers the object in the memo.  This allows us
            to create new schemes for duplicating / registering objects
            that reuse all the logic here for copying the state.

            """
            ...
        
        def __getstate__(self): # -> list[Any]:
            """Generic implementation of `__getstate__`

            This implementation will collect the slots (in order) and
            then the `__dict__` (if necessary) and place everything into a
            `list`.  This standard format is significantly faster to
            generate and deepcopy (when compared to a `dict`), although
            it can be more fragile (changing the number of slots can
            cause a pickle to no longer be loadable)

            Derived classes should not overload this method to provide
            special handling for fields (e.g., to resolve weak
            references).  Instead, special field handlers should be
            declared via the `__autoslot_mappers__` class attribute (see
            :py:class:`AutoSlots`)

            """
            ...
        
        def __setstate__(self, state): # -> None:
            """Generic implementation of `__setstate__`

            Restore the state generated by :py:meth:`__getstate__()`

            Derived classes should not overload this method to provide
            special handling for fields (e.g., to restore weak
            references).  Instead, special field handlers should be
            declared via the `__autoslot_mappers__` class attribute (see
            :py:class:`AutoSlots`)

            """
            ...
        
    
    


