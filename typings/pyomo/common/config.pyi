"""
This type stub file was generated by pyright.
"""

import enum
from pyomo.common.collections import Mapping, Sequence
from pyomo.common.deprecation import deprecated

logger = ...
USER_OPTION = ...
ADVANCED_OPTION = ...
DEVELOPER_OPTION = ...
def Bool(val): # -> bool:
    """Domain validator for bool-like objects.

    This is a more strict domain than ``bool``, as it will error on
    values that do not "look" like a Boolean value (i.e., it accepts
    ``True``, ``False``, 0, 1, and the case insensitive strings
    ``'true'``, ``'false'``, ``'yes'``, ``'no'``, ``'t'``, ``'f'``,
    ``'y'``, and ``'n'``)

    """
    ...

def Integer(val): # -> int:
    """Domain validation function admitting integers

    This domain will admit integers, as well as any values that are
    "reasonably exactly" convertible to integers.  This is more strict
    than ``int``, as it will generate errors for floating point values
    that are not integer.

    """
    ...

def PositiveInt(val): # -> int:
    """Domain validation function admitting strictly positive integers

    This domain will admit positive integers (n > 0), as well as any
    types that are convertible to positive integers.

    """
    ...

def NegativeInt(val): # -> int:
    """Domain validation function admitting strictly negative integers

    This domain will admit negative integers (n < 0), as well as any
    types that are convertible to negative integers.

    """
    ...

def NonPositiveInt(val): # -> int:
    """Domain validation function admitting integers <= 0

    This domain will admit non-positive integers (n <= 0), as well as
    any types that are convertible to non-positive integers.

    """
    ...

def NonNegativeInt(val): # -> int:
    """Domain validation function admitting integers >= 0

    This domain will admit non-negative integers (n >= 0), as well as
    any types that are convertible to non-negative integers.

    """
    ...

def PositiveFloat(val): # -> float:
    """Domain validation function admitting strictly positive numbers

    This domain will admit positive floating point numbers (n > 0), as
    well as any types that are convertible to positive floating point
    numbers.

    """
    ...

def NegativeFloat(val): # -> float:
    """Domain validation function admitting strictly negative numbers

    This domain will admit negative floating point numbers (n < 0), as
    well as any types that are convertible to negative floating point
    numbers.

    """
    ...

def NonPositiveFloat(val): # -> float:
    """Domain validation function admitting numbers less than or equal to 0

    This domain will admit non-positive floating point numbers (n <= 0),
    as well as any types that are convertible to non-positive floating
    point numbers.

    """
    ...

def NonNegativeFloat(val): # -> float:
    """Domain validation function admitting numbers greater than or equal to 0

    This domain will admit non-negative floating point numbers (n >= 0),
    as well as any types that are convertible to non-negative floating
    point numbers.

    """
    ...

class In:
    """In(domain, cast=None)
    Domain validation class admitting a Container of possible values

    This will admit any value that is in the `domain` Container (i.e.,
    Container.__contains__() returns True).  Most common domains are
    list, set, and dict objects.  If specified, incoming values are
    first passed to `cast()` to convert them to the appropriate type
    before looking them up in `domain`.

    Parameters
    ----------
    domain: Container
        The container that specifies the allowable values.  Incoming
        values are passed to ``domain.__contains__()``, and if ``True``
        is returned, the value is accepted and returned.

    cast: Callable, optional
        A callable object.  If specified, incoming values are first
        passed to `cast`, and the resulting object is checked for
        membership in `domain`

    Note
    ----
    For backwards compatibility, `In` accepts `enum.Enum` classes as
    `domain` Containers.  If the domain is an Enum, then the constructor
    returns an instance of `InEnum`.

    """
    def __new__(cls, domain=..., cast=...): # -> InEnum:
        ...
    
    def __init__(self, domain, cast=...) -> None:
        ...
    
    def __call__(self, value):
        ...
    
    def domain_name(self): # -> str:
        ...
    


class InEnum:
    """Domain validation class admitting an enum value/name.

    This will admit any value that is in the specified Enum, including
    Enum members, values, and string names.  The incoming value will be
    automatically cast to an Enum member.

    Parameters
    ----------
    domain: enum.Enum
        The enum that incoming values should be mapped to

    """
    def __init__(self, domain) -> None:
        ...
    
    def __call__(self, value):
        ...
    
    def domain_name(self): # -> str:
        ...
    


class IsInstance:
    """
    Domain validator for type checking.

    Parameters
    ----------
    *bases : tuple of type
        Valid types.
    document_full_base_names : bool, optional
        True to prepend full module qualifier to the name of each
        member of `bases` in ``self.domain_name()`` and/or any
        error messages generated by this object, False otherwise.
    """
    def __init__(self, *bases, document_full_base_names=...) -> None:
        ...
    
    def __call__(self, obj):
        ...
    
    def domain_name(self): # -> str:
        ...
    


class ListOf:
    """Domain validator for lists of a specified type

    Parameters
    ----------
    itemtype: type
        The type for each element in the list

    domain: Callable
        A domain validator (callable that takes the incoming value,
        validates it, and returns the appropriate domain type) for each
        element in the list.  If not specified, defaults to the
        `itemtype`.

    string_lexer: Callable
        A preprocessor (lexer) called for all string values.  If
        NOTSET, then strings are split on whitespace and/or commas
        (honoring simple use of single or double quotes).  If None, then
        no tokenization is performed.

    """
    def __init__(self, itemtype, domain=..., string_lexer=...) -> None:
        ...
    
    def __call__(self, value): # -> list[Any]:
        ...
    
    def domain_name(self): # -> str:
        ...
    


class Module:
    """Domain validator for modules.

    Modules can be specified as module objects, by module name,
    or by the path to the module's file. If specified by path, the
    path string has the same path expansion features supported by
    the :py:class:`Path` class.

    Note that modules imported by file path may not be recognized as
    part of a package, and as such they should not use relative package
    importing (such as ``from . import foo``).

    Parameters
    ----------
    basePath : None, str, ConfigValue
        The base path that will be prepended to any non-absolute path
        values provided.  If None, defaults to :py:attr:`Path.BasePath`.

    expandPath : bool
        If True, then the value will be expanded and normalized.  If
        False, the string representation of the value will be used
        unchanged.  If None, expandPath will defer to the (negated)
        value of :py:attr:`Path.SuppressPathExpansion`.

    Examples
    --------

    The following code shows the three ways you can specify a module: by file
    name, by module name, or by module object. Regardless of how the module is
    specified, what is stored in the configuration is a module object.

    .. testcode::

        from pyomo.common.config import (
            ConfigDict, ConfigValue, Module
        )
        config = ConfigDict()
        config.declare('my_module', ConfigValue(
            domain=Module(),
        ))
        # Set using file path
        config.my_module = '../../pyomo/common/tests/config_plugin.py'
        # Set using python module name, as a string
        config.my_module = 'os.path'
        # Set using an imported module object
        import os.path
        config.my_module = os.path

    """
    def __init__(self, basePath=..., expandPath=...) -> None:
        ...
    
    def __call__(self, module_id): # -> ModuleType:
        ...
    


class Path:
    """
    Domain validator for a
    :py:term:`path-like object <path-like object>`.

    This will admit a path-like object
    and get the object's file system representation
    through :py:obj:`os.fsdecode`.
    It will then
    expand any environment variables and leading usernames (e.g.,
    "~myuser" or "~/") appearing in either the value or the base path
    before concatenating the base path and value, expanding the path to
    an absolute path, and normalizing the path.

    Parameters
    ----------
    basePath: None, str, ConfigValue
        The base path that will be prepended to any non-absolute path
        values provided.  If None, defaults to :py:attr:`Path.BasePath`.

    expandPath: bool
        If True, then the value will be expanded and normalized.  If
        False, the string representation of the value will be returned
        unchanged.  If None, expandPath will defer to the (negated)
        value of :py:attr:`Path.SuppressPathExpansion`

    """
    BasePath = ...
    SuppressPathExpansion = ...
    def __init__(self, basePath=..., expandPath=...) -> None:
        ...
    
    def __call__(self, path): # -> str:
        ...
    
    def domain_name(self): # -> str | None:
        ...
    


class PathList(Path):
    """
    Domain validator for a list of
    :py:term:`path-like objects <path-like object>`.

    This admits a path-like object or iterable of such.
    If a path-like object is passed, then
    a singleton list containing the object normalized through
    :py:class:`Path` is returned.
    An iterable of path-like objects is cast to a list, each
    entry of which is normalized through :py:class:`Path`.

    Parameters
    ----------
    basePath: Union[None, str, ConfigValue]
        The base path that will be prepended to any non-absolute path
        values provided.  If None, defaults to :py:attr:`Path.BasePath`.

    expandPath: bool
        If True, then the value will be expanded and normalized.  If
        False, the string representation of the value will be returned
        unchanged.  If None, expandPath will defer to the (negated)
        value of :py:attr:`Path.SuppressPathExpansion`

    """
    def __call__(self, data): # -> list[str]:
        ...
    


class DynamicImplicitDomain:
    """Implicit domain that can return a custom domain based on the key.

    This provides a mechanism for managing plugin-like systems, where
    the key specifies a source for additional configuration information.
    For example, given the plugin module,
    ``pyomo/common/tests/config_plugin.py``:

    .. literalinclude:: /../../pyomo/common/tests/config_plugin.py
       :start-at: import

    .. doctest::
       :hide:

       >>> import importlib
       >>> import pyomo.common.fileutils
       >>> from pyomo.common.config import ConfigDict, DynamicImplicitDomain

    Then we can declare a `:class:``ConfigDict`` that imports the domain
    for specific keys from a module that matches the key name:

    .. testcode::

       def _pluginImporter(name, config):
           mod = importlib.import_module(name)
           return mod.get_configuration(config)
       config = ConfigDict()
       config.declare('plugins', ConfigDict(
           implicit=True,
           implicit_domain=DynamicImplicitDomain(_pluginImporter)))
       config.plugins['pyomo.common.tests.config_plugin'] = {'key1': 5}
       config.display()


    .. testoutput::

       plugins:
         pyomo.common.tests.config_plugin:
           key1: 5
           key2: '5'

    .. note::

       This initializer is only useful for the :py:class:`ConfigDict`
       ``implicit_domain`` argument (and not for "regular" ``domain``
       arguments)

    Parameters
    ----------
    callback: Callable[[str, object], ConfigBase]
        A callable (function) that is passed the ConfigDict key and
        value, and is expected to return the appropriate Config object
        (ConfigValue, ConfigList, or ConfigDict)

    """
    def __init__(self, callback) -> None:
        ...
    
    def __call__(self, key, value):
        ...
    


@deprecated()
class ConfigEnum(enum.Enum):
    @deprecated("The ConfigEnum base class is deprecated.  " "Directly inherit from enum.Enum and then use " "In() or InEnum() as the ConfigValue 'domain' for " "validation and int/string type conversions.", version='6.0')
    def __new__(cls, value, *args): # -> Self:
        ...
    
    @classmethod
    def from_enum_or_string(cls, arg): # -> ConfigEnum | Self:
        ...
    


__doc__ = ...
_leadingSpace = ...
class _UnpickleableDomain:
    def __init__(self, obj) -> None:
        ...
    
    def __call__(self, arg):
        ...
    


_store_bool = ...
class ConfigFormatter:
    def generate(self, config, indent_spacing=..., width=..., visibility=...): # -> str:
        ...
    


class String_ConfigFormatter(ConfigFormatter):
    def __init__(self, block_start, block_end, item_start, item_body, item_end) -> None:
        ...
    


class LaTeX_ConfigFormatter(String_ConfigFormatter):
    def __init__(self) -> None:
        ...
    


class numpydoc_ConfigFormatter(ConfigFormatter):
    ...


@deprecated("add_docstring_list is deprecated.  Please use the " "@document_kwargs_from_configdict() decorator.", version='6.6.0')
def add_docstring_list(docstring, configdict, indent_by=...):
    """Returns the docstring with a formatted configuration arguments listing."""
    ...

class document_kwargs_from_configdict:
    """Decorator to append the documentation of a ConfigDict to the docstring

    This adds the documentation of the specified :py:class:`ConfigDict`
    (using the :py:class:`numpydoc_ConfigFormatter` formatter) to the
    decorated object's docstring.

    Parameters
    ----------
    config : ConfigDict or str
        the :py:class:`ConfigDict` to document.  If a ``str``, then the
        :py:class:`ConfigDict` is obtained by retrieving the named
        attribute from the decorated object (thereby enabling
        documenting class objects whose ``__init__`` keyword arguments
        are processed by a :py:class:`ConfigDict` class attribute)

    section : str
        the section header to preface config documentation with

    indent_spacing : int
        number of spaces to indent each block of documentation

    width : int
        total documentation width in characters (for wrapping paragraphs)

    doc : str, optional
        the initial docstring to append the ConfigDict documentation to.
        If None, then the decorated object's ``__doc__`` will be used.

    Examples
    --------

    >>> from pyomo.common.config import (
    ...     ConfigDict, ConfigValue, document_kwargs_from_configdict
    ... )
    >>> class MyClass(object):
    ...     CONFIG = ConfigDict()
    ...     CONFIG.declare('iterlim', ConfigValue(
    ...         default=3000,
    ...         domain=int,
    ...         doc="Iteration limit.  Specify None for no limit"
    ...     ))
    ...     CONFIG.declare('tee', ConfigValue(
    ...         domain=bool,
    ...         doc="If True, stream the solver output to the console"
    ...     ))
    ...
    ...     @document_kwargs_from_configdict(CONFIG)
    ...     def solve(self, **kwargs):
    ...         config = self.CONFIG(kwargs)
    ...         # ...
    ...
    >>> help(MyClass.solve)
    Help on function solve:
    <BLANKLINE>
    solve(self, **kwargs)
        Keyword Arguments
        -----------------
        iterlim: int, default=3000
            Iteration limit.  Specify None for no limit
    <BLANKLINE>
        tee: bool, optional
            If True, stream the solver output to the console

    """
    def __init__(self, config, section=..., indent_spacing=..., width=..., visibility=..., doc=...) -> None:
        ...
    
    def __call__(self, fcn):
        ...
    


class UninitializedMixin:
    """Mixin class to support delayed data initialization.

    This mixin can be used to create a derived Config class that hides
    the (uninitialized) ``_data`` attribute behind a property.  Any
    attempt to access the ``_data`` will trigger the initialization of the
    Config object from its ``_default`` value.  Setting the ``_data``
    attribute will also trigger resolution of the Config object, but
    without processing the ``_default__``.

    """
    __slots__ = ...


class ConfigBase:
    __slots__ = ...
    class NoArgument:
        ...
    
    
    def __init__(self, default=..., domain=..., description=..., doc=..., visibility=...) -> None:
        ...
    
    def __getstate__(self): # -> list[Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __call__(self, value=..., default=..., domain=..., description=..., doc=..., visibility=..., implicit=..., implicit_domain=..., preserve_implicit=...): # -> ConfigBase | ConfigDict:
        ...
    
    def name(self, fully_qualified=...): # -> Literal['']:
        ...
    
    def domain_name(self): # -> str:
        ...
    
    def set_default_value(self, default): # -> None:
        ...
    
    def set_domain(self, domain): # -> None:
        ...
    
    def reset(self): # -> None:
        ...
    
    def declare_as_argument(self, *args, **kwds): # -> Self:
        """Map this Config item to an argparse argument.

        Valid arguments include all valid arguments to argparse's
        ArgumentParser.add_argument() with the exception of 'default'.
        In addition, you may provide a group keyword argument to either
        pass in a pre-defined option group or subparser, or else pass in
        the string name of a group, subparser, or (subparser, group).

        """
        ...
    
    def initialize_argparse(self, parser): # -> None:
        ...
    
    def import_argparse(self, parsed_args):
        ...
    
    def display(self, content_filter=..., indent_spacing=..., ostream=..., visibility=...): # -> None:
        ...
    
    def generate_yaml_template(self, indent_spacing=..., width=..., visibility=...): # -> str:
        ...
    
    def generate_documentation(self, block_start=..., block_end=..., item_start=..., item_body=..., item_end=..., indent_spacing=..., width=..., visibility=..., format=...):
        ...
    
    def user_values(self): # -> Generator[Self | Any, Any, None]:
        ...
    
    def unused_user_values(self): # -> Generator[Self | Any, Any, None]:
        ...
    


class ConfigValue(ConfigBase):
    """Store and manipulate a single configuration value.

    Parameters
    ----------
    default: optional
        The default value that this ConfigValue will take if no value is
        provided.

    domain: Callable, optional
        The domain can be any callable that accepts a candidate value
        and returns the value converted to the desired type, optionally
        performing any data validation.  The result will be stored into
        the ConfigValue.  Examples include type constructors like `int`
        or `float`.  More complex domain examples include callable
        objects; for example, the :py:class:`In` class that ensures that
        the value falls into an acceptable set or even a complete
        :py:class:`ConfigDict` instance.

    description: str, optional
        The short description of this value

    doc: str, optional
        The long documentation string for this value

    visibility: int, optional
        The visibility of this ConfigValue when generating templates and
        documentation.  Visibility supports specification of "advanced"
        or "developer" options.  ConfigValues with visibility=0 (the
        default) will always be printed / included.  ConfigValues
        with higher visibility values will only be included when the
        generation method specifies a visibility greater than or equal
        to the visibility of this object.

    """
    __slots__ = ...
    def value(self, accessValue=...):
        ...
    
    def set_value(self, value): # -> None:
        ...
    


class ImmutableConfigValue(ConfigValue):
    __slots__ = ...
    def __new__(self, *args, **kwds): # -> ConfigValue:
        ...
    


class MarkImmutable:
    """
    Mark instances of ConfigValue as immutable.

    Parameters
    ----------
    config_value: ConfigValue
        The ConfigValue instances that should be marked immutable.
        Note that multiple instances of ConfigValue can be passed.

    Examples
    --------
    .. testcode::

       config = ConfigDict()
       config.declare('a', ConfigValue(default=1, domain=int))
       config.declare('b', ConfigValue(default=1, domain=int))
       locker = MarkImmutable(config.get('a'), config.get('b'))

    Now, config.a and config.b cannot be changed:

    .. doctest::

       >>> config.a = 5
       Traceback (most recent call last):
          ...
       RuntimeError: ConfigValue 'a' is currently immutable
       >>> print(config.a)
       1

    To make them mutable again,

    .. doctest::

       >>> locker.release_lock()
       >>> config.a = 5
       >>> print(config.a)
       5

    Note that this can be used as a context manager as well:

    .. doctest::

       >>> with MarkImmutable(config.get('a'), config.get('b')):
       ...     config.a = 10
       Traceback (most recent call last):
          ...
       RuntimeError: ConfigValue 'a' is currently immutable
       >>> print(config.a)
       5
       >>> config.a = 10
       >>> print(config.a)
       10

    """
    def __init__(self, *args) -> None:
        ...
    
    def lock(self): # -> None:
        ...
    
    def release_lock(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, t, v, tb): # -> None:
        ...
    


class ConfigList(ConfigBase, Sequence):
    """Store and manipulate a list of configuration values.

    Parameters
    ----------
    default: optional
        The default value that this ConfigList will take if no value is
        provided.  If default is a list or ConfigList, then each member
        is cast to the ConfigList's domain to build the default value,
        otherwise the default is cast to the domain and forms a default
        list with a single element.

    domain: Callable, optional
        The domain can be any callable that accepts a candidate value
        and returns the value converted to the desired type, optionally
        performing any data validation.  The result will be stored /
        added to the ConfigList.  Examples include type constructors
        like `int` or `float`.  More complex domain examples include
        callable objects; for example, the :py:class:`In` class that
        ensures that the value falls into an acceptable set or even a
        complete :py:class:`ConfigDict` instance.

    description: str, optional
        The short description of this list

    doc: str, optional
        The long documentation string for this list

    visibility: int, optional
        The visibility of this ConfigList when generating templates and
        documentation.  Visibility supports specification of "advanced"
        or "developer" options.  ConfigLists with visibility=0 (the
        default) will always be printed / included.  ConfigLists
        with higher visibility values will only be included when the
        generation method specifies a visibility greater than or equal
        to the visibility of this object.

    """
    __slots__ = ...
    def __init__(self, default=..., domain=..., description=..., doc=..., visibility=...) -> None:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def get(self, key, default=...):
        ...
    
    def __setitem__(self, key, val): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Generator[Any, None, None]:
        ...
    
    def value(self, accessValue=...): # -> list[Any]:
        ...
    
    def set_value(self, value): # -> None:
        ...
    
    def append(self, value=...): # -> None:
        ...
    
    @deprecated("ConfigList.add() has been deprecated.  Use append()", version='5.7.2')
    def add(self, value=...): # -> None:
        "Append the specified value to the list, casting as necessary."
        ...
    


class ConfigDict(ConfigBase, Mapping):
    """Store and manipulate a dictionary of configuration values.

    Parameters
    ----------
    description: str, optional
        The short description of this list

    doc: str, optional
        The long documentation string for this list

    implicit: bool, optional
        If True, the ConfigDict will allow "implicitly" declared
        keys, that is, keys can be stored into the ConfigDict that
        were not previously declared using :py:meth:`declare` or
        :py:meth:`declare_from`.

    implicit_domain: Callable, optional
        The domain that will be used for any implicitly-declared keys.
        Follows the same rules as :py:meth:`ConfigValue`'s `domain`.

    visibility: int, optional
        The visibility of this ConfigDict when generating templates and
        documentation.  Visibility supports specification of "advanced"
        or "developer" options.  ConfigDicts with visibility=0 (the
        default) will always be printed / included.  ConfigDicts
        with higher visibility values will only be included when the
        generation method specifies a visibility greater than or equal
        to the visibility of this object.

    """
    content_filters = ...
    __slots__ = ...
    _reserved_words = ...
    def __init__(self, description=..., doc=..., implicit=..., implicit_domain=..., visibility=...) -> None:
        ...
    
    def domain_name(self): # -> str:
        ...
    
    def __getstate__(self): # -> list[Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __dir__(self): # -> list[Any]:
        ...
    
    def __getitem__(self, key):
        ...
    
    def get(self, key, default=...): # -> ConfigBase | ConfigDict | ConfigValue | None:
        ...
    
    def setdefault(self, key, default=...): # -> ConfigBase | ConfigValue | ConfigDict:
        ...
    
    def __setitem__(self, key, val): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> map[Any]:
        ...
    
    def __getattr__(self, attr):
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __delattr__(self, name): # -> None:
        ...
    
    def keys(self): # -> map[Any]:
        ...
    
    def values(self): # -> map[Any]:
        ...
    
    def items(self): # -> Generator[tuple[Any, Any], Any, None]:
        ...
    
    @deprecated('The iterkeys method is deprecated. Use dict.keys().', version='6.0')
    def iterkeys(self): # -> map[Any]:
        ...
    
    @deprecated('The itervalues method is deprecated. Use dict.keys().', version='6.0')
    def itervalues(self): # -> map[Any]:
        ...
    
    @deprecated('The iteritems method is deprecated. Use dict.keys().', version='6.0')
    def iteritems(self): # -> Generator[tuple[Any, Any], Any, None]:
        ...
    
    def declare(self, name, config):
        ...
    
    def declare_from(self, other, skip=...): # -> None:
        ...
    
    def add(self, name, config): # -> ConfigBase | ConfigValue | ConfigDict:
        ...
    
    def value(self, accessValue=...): # -> dict[Any, Any]:
        ...
    
    def set_value(self, value, skip_implicit=...): # -> Self:
        ...
    
    def reset(self): # -> None:
        ...
    


ConfigBlock = ConfigDict
