"""
This type stub file was generated by pyright.
"""

from pyomo.common.deprecation import deprecated

logger = ...
nonpyomo_leaf_types = ...
native_numeric_types = ...
native_integer_types = ...
native_logical_types = ...
native_complex_types = ...
_native_boolean_types = ...
_pyomo_constant_types = ...
native_types = ...
def RegisterNumericType(new_type: type): # -> None:
    """Register the specified type as a "numeric type".

    A utility function for registering new types as "native numeric
    types" that can be leaf nodes in Pyomo numeric expressions.  The
    type should be compatible with :py:class:`float` (that is, store a
    scalar and be castable to a Python float).

    Parameters
    ----------
    new_type : type
        The new numeric type (e.g, `numpy.float64`)

    """
    ...

def RegisterIntegerType(new_type: type): # -> None:
    """Register the specified type as an "integer type".

    A utility function for registering new types as "native integer
    types".  Integer types can be leaf nodes in Pyomo numeric
    expressions.  The type should be compatible with :py:class:`float`
    (that is, store a scalar and be castable to a Python float).

    Registering a type as an integer type implies
    :py:func:`RegisterNumericType`.

    Note that integer types are NOT registered as logical / Boolean types.

    Parameters
    ----------
    new_type : type
        The new integer type (e.g, `numpy.int64`)

    """
    ...

@deprecated("The native_boolean_types set (and hence RegisterBooleanType) " "is deprecated.  Users likely should use RegisterLogicalType.", version='6.6.0')
def RegisterBooleanType(new_type: type): # -> None:
    """Register the specified type as a "logical type".

    A utility function for registering new types as "native logical
    types".  Logical types can be leaf nodes in Pyomo logical
    expressions.  The type should be compatible with :py:class:`bool`
    (that is, store a scalar and be castable to a Python bool).

    Note that logical types are NOT registered as numeric types.

    Parameters
    ----------
    new_type : type
        The new logical type (e.g, `numpy.bool_`)

    """
    ...

def RegisterComplexType(new_type: type): # -> None:
    """Register the specified type as an "complex type".

    A utility function for registering new types as "native complex
    types".  Complex types can NOT be leaf nodes in Pyomo numeric
    expressions.  The type should be compatible with :py:class:`complex`
    (that is, store a scalar complex value and be castable to a Python
    complex).

    Note that complex types are NOT registered as logical or numeric types.

    Parameters
    ----------
    new_type : type
        The new complex type (e.g, `numpy.complex128`)

    """
    ...

def RegisterLogicalType(new_type: type): # -> None:
    """Register the specified type as a "logical type".

    A utility function for registering new types as "native logical
    types".  Logical types can be leaf nodes in Pyomo logical
    expressions.  The type should be compatible with :py:class:`bool`
    (that is, store a scalar and be castable to a Python bool).

    Note that logical types are NOT registered as numeric types.

    Parameters
    ----------
    new_type : type
        The new logical type (e.g, `numpy.bool_`)

    """
    ...

def check_if_native_type(obj): # -> bool:
    ...

def check_if_logical_type(obj): # -> bool:
    """Test if the argument behaves like a logical type.

    We check for "logical types" by checking if the type returns sane
    results for Boolean operators (``^``, ``|``, ``&``) and if it maps
    ``1`` and ``2`` both to the same equivalent instance.  If that
    works, then we register the type in :py:attr:`native_logical_types`.

    """
    ...

def check_if_numeric_type(obj): # -> bool:
    """Test if the argument behaves like a numeric type.

    We check for "numeric types" by checking if we can add zero to it
    without changing the object's type, and that the object compares to
    0 in a meaningful way.  If that works, then we register the type in
    :py:attr:`native_numeric_types`.

    """
    ...

def value(obj, exception=...): # -> None:
    """
    A utility function that returns the value of a Pyomo object or
    expression.

    Args:
        obj: The argument to evaluate. If it is None, a
            string, or any other primitive numeric type,
            then this function simply returns the argument.
            Otherwise, if the argument is a NumericValue
            then the __call__ method is executed.
        exception (bool): If :const:`True`, then an exception should
            be raised when instances of NumericValue fail to
            evaluate due to one or more objects not being
            initialized to a numeric value (e.g, one or more
            variables in an algebraic expression having the
            value None). If :const:`False`, then the function
            returns :const:`None` when an exception occurs.
            Default is True.

    Returns: A numeric value or None.
    """
    ...

