"""
This type stub file was generated by pyright.
"""

import collections
from pyomo.common import enums
from pyomo.core.pyomoobject import PyomoObject

logger = ...
valid_expr_ctypes_minlp = ...
valid_active_ctypes_minlp = ...
sum_like_expression_types = ...
_named_subexpression_types = ...
HALT_ON_EVALUATION_ERROR = ...
nan = ...
int_float = ...
class ExprType(enums.IntEnum):
    CONSTANT = ...
    FIXED = ...
    VARIABLE = ...
    MONOMIAL = ...
    LINEAR = ...
    QUADRATIC = ...
    GENERAL = ...


_FileDeterminism_deprecation = ...
class FileDeterminism(enums.IntEnum):
    NONE = ...
    ORDERED = ...
    SORT_INDICES = ...
    SORT_SYMBOLS = ...
    def __str__(self) -> str:
        ...
    
    def __format__(self, spec): # -> str:
        ...
    


class InvalidNumber(PyomoObject):
    def __init__(self, value, cause=...) -> None:
        ...
    
    @staticmethod
    def parse_args(*args): # -> tuple[list[Any], list[Any]]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __format__(self, format_spec):
        ...
    
    def __float__(self):
        ...
    
    def __neg__(self): # -> InvalidNumber:
        ...
    
    def __abs__(self): # -> InvalidNumber:
        ...
    
    def __add__(self, other): # -> InvalidNumber:
        ...
    
    def __sub__(self, other): # -> InvalidNumber:
        ...
    
    def __mul__(self, other): # -> InvalidNumber:
        ...
    
    def __truediv__(self, other): # -> InvalidNumber:
        ...
    
    def __pow__(self, other): # -> InvalidNumber:
        ...
    
    def __radd__(self, other): # -> InvalidNumber:
        ...
    
    def __rsub__(self, other): # -> InvalidNumber:
        ...
    
    def __rmul__(self, other): # -> InvalidNumber:
        ...
    
    def __rtruediv__(self, other): # -> InvalidNumber:
        ...
    
    def __rpow__(self, other): # -> InvalidNumber:
        ...
    


_CONSTANT = ...
class BeforeChildDispatcher(collections.defaultdict):
    """Dispatcher for handling the :class:`StreamBasedExpressionVisitor`
    `beforeChild` callback

    This dispatcher implements a specialization of :class:`defaultdict`
    that supports automatic type registration.  Any missing types will
    return the :meth:`register_dispatcher` method, which (when called
    as a callback) will interrogate the type, identify the appropriate
    callback, add the callback to the dict, and return the result of
    calling the callback.  As the callback is added to the dict, no type
    will incur the overhead of `register_dispatcher` more than once.

    Note that all dispatchers are implemented as `staticmethod`
    functions to avoid the (unnecessary) overhead of binding to the
    dispatcher object.

    """
    __slots__ = ...
    def __missing__(self, key): # -> Callable[..., Any]:
        ...
    
    def register_dispatcher(self, visitor, child):
        ...
    


class ExitNodeDispatcher(collections.defaultdict):
    """Dispatcher for handling the :class:`StreamBasedExpressionVisitor`
    `exitNode` callback

    This dispatcher implements a specialization of :class:`defaultdict`
    that supports automatic type registration.  As the identified
    callback is added to the dict, no type will incur the overhead of
    `register_dispatcher` more than once.

    Note that in this case, the client is expected to register all
    non-NPV expression types.  The auto-registration is designed to only
    handle two cases:
    - Auto-detection of user-defined Named Expression types
    - Automatic mappimg of NPV expressions to their equivalent non-NPV handlers
    - Automatic registration of derived expression types

    """
    __slots__ = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __missing__(self, key): # -> Callable[..., Any]:
        ...
    
    def unexpected_expression_type(self, visitor, node, *args):
        ...
    


def initialize_exit_node_dispatcher(exit_handlers): # -> dict[Any, Any]:
    ...

def apply_node_operation(node, args): # -> InvalidNumber:
    ...

def complex_number_error(value, visitor, expr, node=...): # -> InvalidNumber:
    ...

def categorize_valid_components(model, active=..., sort=..., valid=..., targets=...): # -> tuple[dict[Any, list[Any]], dict[Any, Any]]:
    """Walk model and check for valid component types

    This routine will walk the model and check all component types.
    Components types in the `valid` set are ignored, blocks with
    components in the `targets` set are collected, and all other
    component types are added to a dictionary of `unrecognized`
    components.

    A Component type may not appear in both `valid` and `targets` sets.

    Parameters
    ----------
    model: BlockData
        The model tree to walk

    active: True or None
        If True, only unrecognized active components are returned in the
        `uncategorized` dictionary.  Also, if True, only active Blocks
        are descended into.

    sort: bool or SortComponents
        The sorting flag to pass to the block walkers

    valid: Set[type]
        The set of "valid" component types.  These are ignored by the
        categorizer.

    targets: Set[type]
        The set of component types to "collect".  Blocks with components
        in the `targets` set will be returned in the `component_map`

    Returns
    -------
    component_map: Dict[type, List[BlockData]]
        A dict mapping component type to a list of block data
        objects that contain declared component of that type.

    unrecognized: Dict[type, List[ComponentData]]
        A dict mapping unrecognized component types to a (non-empty)
        list of component data objects found on the model.

    """
    ...

def FileDeterminism_to_SortComponents(file_determinism): # -> SortComponents:
    ...

def initialize_var_map_from_column_order(model, config, var_map):
    ...

def ordered_active_constraints(model, config): # -> list[Any]:
    ...

class VarRecorder:
    def __init__(self, var_map, sorter) -> None:
        ...
    
    def add(self, var): # -> None:
        ...
    


class OrderedVarRecorder:
    def __init__(self, var_map, var_order, sorter) -> None:
        ...
    
    def add(self, var): # -> None:
        ...
    


class TemplateVarRecorder:
    def __init__(self, var_map, var_order, sorter) -> None:
        ...
    
    @property
    def var_order(self): # -> dict[Any, int]:
        ...
    
    def add(self, var): # -> None:
        ...
    


_ftoa_precision_str = ...
def ftoa(val, parenthesize_negative_values=...): # -> str:
    ...

