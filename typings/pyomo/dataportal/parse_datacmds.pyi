"""
This type stub file was generated by pyright.
"""

import ply.lex as lex

_re_number = ...
_parse_info = ...
states = ...
reserved = ...
tokens = ...
t_ignore = ...
t_COMMA = ...
t_LBRACKET = ...
t_RBRACKET = ...
t_LBRACE = ...
t_RBRACE = ...
t_COLON = ...
t_EQ = ...
t_TR = ...
t_LPAREN = ...
t_RPAREN = ...
t_ASTERISK = ...
@lex.TOKEN(r'[\n]+')
def t_newline(t): # -> None:
    ...

_re_singleline_comment = ...
_re_multiline_comment = ...
@lex.TOKEN('|'.join([_re_singleline_comment, _re_multiline_comment]))
def t_COMMENT(t): # -> None:
    ...

@lex.TOKEN(r':=')
def t_COLONEQ(t):
    ...

@lex.TOKEN(r';')
def t_SEMICOLON(t):
    ...

@lex.TOKEN(_re_number + r'(?=[\s()\[\]{}:;,])')
def t_NUM_VAL(t):
    ...

@lex.TOKEN(r'[a-zA-Z_][a-zA-Z0-9_\.\-]*\[')
def t_WORDWITHLBRACKET(t):
    ...

@lex.TOKEN(r'[a-zA-Z_][a-zA-Z_0-9\.+\-]*')
def t_WORD(t):
    ...

@lex.TOKEN(r'[a-zA-Z0-9_\.+\-\\\/]+')
def t_STRING(t):
    ...

@lex.TOKEN(r'[a-zA-Z0-9_\.+\-]*\[[a-zA-Z0-9_\.+\-\*,\s]+\]')
def t_data_BRACKETEDSTRING(t):
    ...

_re_quoted_str = ...
@lex.TOKEN("|".join([_re_quoted_str, _re_quoted_str.replace('"', "'")]))
def t_QUOTEDSTRING(t):
    ...

def t_error(t):
    ...

def p_expr(p): # -> None:
    '''expr : statements
    |'''
    ...

def p_statements(p): # -> None:
    '''statements : statements statement
    | statement
    | statements NAMESPACE WORD LBRACE statements RBRACE
    | NAMESPACE WORD LBRACE statements RBRACE'''
    ...

def p_statement(p): # -> None:
    '''statement : SET WORD COLONEQ datastar SEMICOLON
    | SET WORDWITHLBRACKET args RBRACKET COLONEQ datastar SEMICOLON
    | SET WORD COLON itemstar COLONEQ datastar SEMICOLON
    | PARAM items COLONEQ datastar SEMICOLON
    | TABLE items COLONEQ datastar SEMICOLON
    | LOAD items SEMICOLON
    | STORE items SEMICOLON
    | INCLUDE WORD SEMICOLON
    | INCLUDE QUOTEDSTRING SEMICOLON
    | DATA SEMICOLON
    | END SEMICOLON
    '''
    ...

def p_datastar(p): # -> None:
    '''
    datastar : data
             |
    '''
    ...

def p_data(p): # -> None:
    '''
    data : data NUM_VAL
         | data WORD
         | data STRING
         | data QUOTEDSTRING
         | data BRACKETEDSTRING
         | data SET
         | data TABLE
         | data PARAM
         | data LPAREN
         | data RPAREN
         | data COMMA
         | data ASTERISK
         | NUM_VAL
         | WORD
         | STRING
         | QUOTEDSTRING
         | BRACKETEDSTRING
         | SET
         | TABLE
         | PARAM
         | LPAREN
         | RPAREN
         | COMMA
         | ASTERISK
    '''
    ...

def p_args(p): # -> None:
    '''
    args : arg
         |
    '''
    ...

def p_arg(p): # -> None:
    '''
    arg : arg COMMA NUM_VAL
         | arg COMMA WORD
         | arg COMMA STRING
         | arg COMMA QUOTEDSTRING
         | arg COMMA SET
         | arg COMMA TABLE
         | arg COMMA PARAM
         | NUM_VAL
         | WORD
         | STRING
         | QUOTEDSTRING
         | SET
         | TABLE
         | PARAM
    '''
    ...

def p_itemstar(p): # -> None:
    '''
    itemstar : items
             |
    '''
    ...

def p_items(p): # -> None:
    '''
    items : items NUM_VAL
          | items WORD
          | items STRING
          | items QUOTEDSTRING
          | items COMMA
          | items COLON
          | items LBRACE
          | items RBRACE
          | items LBRACKET
          | items RBRACKET
          | items TR
          | items LPAREN
          | items RPAREN
          | items ASTERISK
          | items EQ
          | items SET
          | items TABLE
          | items PARAM
          | NUM_VAL
          | WORD
          | STRING
          | QUOTEDSTRING
          | COMMA
          | COLON
          | LBRACKET
          | RBRACKET
          | LBRACE
          | RBRACE
          | TR
          | LPAREN
          | RPAREN
          | ASTERISK
          | EQ
          | SET
          | TABLE
          | PARAM
    '''
    ...

def p_error(p):
    ...

tabmodule = ...
dat_lexer = ...
dat_yaccer = ...
dat_yaccer_tabfile = ...
def parse_data_commands(data=..., filename=..., debug=..., outputdir=...): # -> dict[Any, Any] | None:
    ...

if __name__ == '__main__':
    ...
